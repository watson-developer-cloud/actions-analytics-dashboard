{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n}; // Internal Imports\n\n\nimport * as Configuration from './configuration';\nimport { Tools } from './tools';\nimport { Events, ScaleTypes } from './interfaces'; // D3\n\nimport { map } from 'd3-collection';\nimport { scaleOrdinal } from 'd3-scale';\nimport { stack } from 'd3-shape';\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\n\nvar ChartModel =\n/** @class */\nfunction () {\n  function ChartModel(services) {\n    // Internal Model state\n    this.state = {\n      options: {}\n    }; // Fill scales & fill related objects\n\n    this.colorScale = {};\n    this.colorClassNames = {};\n    this.services = services;\n  }\n\n  ChartModel.prototype.getAllDataFromDomain = function (groups) {\n    if (!this.getData()) {\n      return null;\n    }\n\n    var options = this.getOptions(); // Remove datasets that have been disabled\n\n    var allData = this.getData();\n    var dataGroups = this.getDataGroups();\n    var groupMapsTo = Tools.getProperty(options, 'data').groupMapsTo;\n    var axesOptions = Tools.getProperty(options, 'axes'); // filter out the groups that are irrelevant to the component\n\n    if (groups) {\n      allData = allData.filter(function (item) {\n        return groups.includes(item.group);\n      });\n    }\n\n    if (axesOptions) {\n      Object.keys(axesOptions).forEach(function (axis) {\n        var mapsTo = axesOptions[axis].mapsTo;\n        var scaleType = axesOptions[axis].scaleType; // make sure linear/log values are numbers\n\n        if (scaleType === ScaleTypes.LINEAR || scaleType === ScaleTypes.LOG) {\n          allData = allData.map(function (datum) {\n            var _a;\n\n            return __assign(__assign({}, datum), (_a = {}, _a[mapsTo] = datum[mapsTo] === null ? datum[mapsTo] : Number(datum[mapsTo]), _a));\n          });\n        } // Check for custom domain\n\n\n        if (mapsTo && axesOptions[axis].domain) {\n          if (scaleType === ScaleTypes.LABELS) {\n            allData = allData.filter(function (datum) {\n              return axesOptions[axis].domain.includes(datum[mapsTo]);\n            });\n          } else {\n            var _a = axesOptions[axis].domain,\n                start_1 = _a[0],\n                end_1 = _a[1]; // Filter out data outside domain if that datapoint is using that axis (has mapsTo property)\n\n            allData = allData.filter(function (datum) {\n              return !(mapsTo in datum) || datum[mapsTo] >= start_1 && datum[mapsTo] <= end_1;\n            });\n          }\n        }\n      });\n    }\n\n    return allData.filter(function (datum) {\n      return dataGroups.find(function (group) {\n        return group.name === datum[groupMapsTo];\n      });\n    });\n  };\n  /**\n   * Charts that have group configs passed into them, only want to retrieve the display data relevant to that chart\n   * @param groups the included datasets for the particular chart\n   */\n\n\n  ChartModel.prototype.getDisplayData = function (groups) {\n    if (!this.get('data')) {\n      return null;\n    }\n\n    var ACTIVE = Configuration.legend.items.status.ACTIVE;\n    var dataGroups = this.getDataGroups(groups);\n    var groupMapsTo = this.getOptions().data.groupMapsTo;\n    var allDataFromDomain = this.getAllDataFromDomain(groups);\n    return allDataFromDomain.filter(function (datum) {\n      return dataGroups.find(function (dataGroup) {\n        return dataGroup.name === datum[groupMapsTo] && dataGroup.status === ACTIVE;\n      });\n    });\n  };\n\n  ChartModel.prototype.getData = function () {\n    return this.get('data');\n  };\n\n  ChartModel.prototype.isDataEmpty = function () {\n    return !this.getData().length;\n  };\n  /**\n   *\n   * @param newData The new raw data to be set\n   */\n\n\n  ChartModel.prototype.setData = function (newData) {\n    var sanitizedData = this.sanitize(Tools.clone(newData));\n    var dataGroups = this.generateDataGroups(sanitizedData);\n    this.set({\n      data: sanitizedData,\n      dataGroups: dataGroups\n    });\n    return sanitizedData;\n  };\n\n  ChartModel.prototype.getDataGroups = function (groups) {\n    var isDataLoading = Tools.getProperty(this.getOptions(), 'data', 'loading'); // No data should be displayed while data is still loading\n\n    if (isDataLoading) {\n      return [];\n    } // if its a combo chart, the specific chart will pass the model the groups it needs\n\n\n    if (groups) {\n      return this.get('dataGroups').filter(function (dataGroup) {\n        return groups.includes(dataGroup.name);\n      });\n    }\n\n    return this.get('dataGroups');\n  };\n\n  ChartModel.prototype.getActiveDataGroups = function (groups) {\n    var ACTIVE = Configuration.legend.items.status.ACTIVE;\n    return this.getDataGroups(groups).filter(function (dataGroup) {\n      return dataGroup.status === ACTIVE;\n    });\n  };\n\n  ChartModel.prototype.getDataGroupNames = function (groups) {\n    var dataGroups = this.getDataGroups(groups);\n    return dataGroups.map(function (dataGroup) {\n      return dataGroup.name;\n    });\n  };\n\n  ChartModel.prototype.getActiveDataGroupNames = function (groups) {\n    var activeDataGroups = this.getActiveDataGroups(groups);\n    return activeDataGroups.map(function (dataGroup) {\n      return dataGroup.name;\n    });\n  };\n\n  ChartModel.prototype.getGroupedData = function (groups) {\n    var displayData = this.getDisplayData(groups);\n    var groupedData = {};\n    var groupMapsTo = this.getOptions().data.groupMapsTo;\n    displayData.map(function (datum) {\n      var group = datum[groupMapsTo];\n\n      if (groupedData[group] !== null && groupedData[group] !== undefined) {\n        groupedData[group].push(datum);\n      } else {\n        groupedData[group] = [datum];\n      }\n    });\n    return Object.keys(groupedData).map(function (groupName) {\n      return {\n        name: groupName,\n        data: groupedData[groupName]\n      };\n    });\n  };\n\n  ChartModel.prototype.getDataValuesGroupedByKeys = function (groups) {\n    var _this = this;\n\n    var options = this.getOptions();\n    var groupMapsTo = options.data.groupMapsTo;\n    var displayData = this.getDisplayData(groups);\n    var stackKeys = map(displayData, function (datum) {\n      var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum);\n\n      return datum[domainIdentifier];\n    }).keys();\n    var axisPosition = this.services.cartesianScales.domainAxisPosition;\n    var scaleType = options.axes[axisPosition].scaleType; // Sort keys\n\n    if (scaleType === ScaleTypes.TIME) {\n      stackKeys.sort(function (a, b) {\n        var dateA = new Date(a);\n        var dateB = new Date(b);\n        return dateA - dateB;\n      });\n    } else if (scaleType === ScaleTypes.LOG || scaleType === ScaleTypes.LINEAR) {\n      stackKeys.sort(function (a, b) {\n        return a - b;\n      });\n    }\n\n    var dataGroupNames = this.getDataGroupNames();\n    return stackKeys.map(function (key) {\n      var correspondingValues = {\n        sharedStackKey: key\n      };\n      dataGroupNames.forEach(function (dataGroupName) {\n        var correspondingDatum = displayData.find(function (datum) {\n          var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum);\n\n          return datum[groupMapsTo] === dataGroupName && datum[domainIdentifier].toString() === key;\n        });\n\n        var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(correspondingValues);\n\n        correspondingValues[dataGroupName] = correspondingDatum ? correspondingDatum[rangeIdentifier] : null;\n      });\n      return correspondingValues;\n    });\n  };\n\n  ChartModel.prototype.getStackedData = function (_a) {\n    var _b = _a.percentage,\n        percentage = _b === void 0 ? false : _b,\n        _c = _a.groups,\n        groups = _c === void 0 ? null : _c;\n    var options = this.getOptions();\n    var groupMapsTo = options.data.groupMapsTo;\n    var dataGroupNames = this.getDataGroupNames(groups);\n    var dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys(groups);\n\n    if (percentage) {\n      var maxByKey_1 = Tools.fromPairs(dataValuesGroupedByKeys.map(function (d) {\n        return [d.sharedStackKey, 0];\n      }));\n      dataValuesGroupedByKeys.forEach(function (d) {\n        dataGroupNames.forEach(function (name) {\n          maxByKey_1[d.sharedStackKey] += d[name];\n        });\n      }); // cycle through data values to get percentage\n\n      dataValuesGroupedByKeys.forEach(function (d) {\n        dataGroupNames.forEach(function (name) {\n          if (maxByKey_1[d.sharedStackKey]) {\n            d[name] = d[name] / maxByKey_1[d.sharedStackKey] * 100;\n          } else {\n            d[name] = 0;\n          }\n        });\n      });\n    }\n\n    return stack().keys(dataGroupNames)(dataValuesGroupedByKeys).map(function (series, i) {\n      // Add data group names to each series\n      return Object.keys(series).filter(function (key) {\n        return !isNaN(key);\n      }).map(function (key) {\n        var element = series[key];\n        element[groupMapsTo] = dataGroupNames[i];\n        return element;\n      });\n    });\n  };\n  /**\n   * @return {Object} The chart's options\n   */\n\n\n  ChartModel.prototype.getOptions = function () {\n    return this.state.options;\n  };\n\n  ChartModel.prototype.set = function (newState, configs) {\n    this.state = Object.assign({}, this.state, newState);\n    var newConfig = Object.assign({\n      skipUpdate: false,\n      animate: true\n    }, // default configs\n    configs);\n\n    if (!newConfig.skipUpdate) {\n      this.update(newConfig.animate);\n    }\n  };\n\n  ChartModel.prototype.get = function (property) {\n    if (property) {\n      return this.state[property];\n    } else {\n      return this.state;\n    }\n  };\n  /**\n   *\n   * @param newOptions New options to be set\n   */\n\n\n  ChartModel.prototype.setOptions = function (newOptions) {\n    var options = this.getOptions();\n    Tools.updateLegendAdditionalItems(options, newOptions);\n    this.set({\n      options: Tools.merge(options, newOptions)\n    });\n  };\n  /**\n   *\n   * Updates miscellanous information within the model\n   * such as the color scales, or the legend data labels\n   */\n\n\n  ChartModel.prototype.update = function (animate) {\n    if (animate === void 0) {\n      animate = true;\n    }\n\n    if (!this.getDisplayData()) {\n      return;\n    }\n\n    this.updateAllDataGroups();\n    this.setCustomColorScale();\n    this.setColorClassNames();\n    this.services.events.dispatchEvent(Events.Model.UPDATE, {\n      animate: animate\n    });\n  };\n  /*\n   * Data labels\n   */\n\n\n  ChartModel.prototype.toggleDataLabel = function (changedLabel) {\n    var _a = Configuration.legend.items.status,\n        ACTIVE = _a.ACTIVE,\n        DISABLED = _a.DISABLED;\n    var dataGroups = this.getDataGroups();\n    var hasDeactivatedItems = dataGroups.some(function (group) {\n      return group.status === DISABLED;\n    });\n    var activeItems = dataGroups.filter(function (group) {\n      return group.status === ACTIVE;\n    }); // If there are deactivated items, toggle \"changedLabel\"\n\n    if (hasDeactivatedItems) {\n      // If the only active item is being toggled\n      // Activate all items\n      if (activeItems.length === 1 && activeItems[0].name === changedLabel) {\n        // If every item is active, then enable \"changedLabel\" and disable all other items\n        dataGroups.forEach(function (group, i) {\n          dataGroups[i].status = ACTIVE;\n        });\n      } else {\n        var indexToChange = dataGroups.findIndex(function (group) {\n          return group.name === changedLabel;\n        });\n        dataGroups[indexToChange].status = dataGroups[indexToChange].status === DISABLED ? ACTIVE : DISABLED;\n      }\n    } else {\n      // If every item is active, then enable \"changedLabel\" and disable all other items\n      dataGroups.forEach(function (group, i) {\n        dataGroups[i].status = group.name === changedLabel ? ACTIVE : DISABLED;\n      });\n    } // Updates selected groups\n\n\n    var updatedActiveItems = dataGroups.filter(function (group) {\n      return group.status === ACTIVE;\n    });\n    var options = this.getOptions();\n    var hasUpdatedDeactivatedItems = dataGroups.some(function (group) {\n      return group.status === DISABLED;\n    }); // If there are deactivated items, map the item name into selected groups\n\n    if (hasUpdatedDeactivatedItems) {\n      options.data.selectedGroups = updatedActiveItems.map(function (activeItem) {\n        return activeItem.name;\n      });\n    } else {\n      // If every item is active, clear array\n      options.data.selectedGroups = [];\n    } // dispatch legend filtering event with the status of all the dataLabels\n\n\n    this.services.events.dispatchEvent(Events.Legend.ITEMS_UPDATE, {\n      dataGroups: dataGroups\n    }); // Update model\n\n    this.set({\n      dataGroups: dataGroups\n    });\n  };\n  /**\n   * Should the data point be filled?\n   * @param group\n   * @param key\n   * @param value\n   * @param defaultFilled the default for this chart\n   */\n\n\n  ChartModel.prototype.getIsFilled = function (group, key, data, defaultFilled) {\n    var options = this.getOptions();\n\n    if (options.getIsFilled) {\n      return options.getIsFilled(group, key, data, defaultFilled);\n    } else {\n      return defaultFilled;\n    }\n  };\n\n  ChartModel.prototype.getFillColor = function (group, key, data) {\n    var options = this.getOptions();\n    var defaultFillColor = Tools.getProperty(this.colorScale, group);\n\n    if (options.getFillColor) {\n      return options.getFillColor(group, key, data, defaultFillColor);\n    } else {\n      return defaultFillColor;\n    }\n  };\n\n  ChartModel.prototype.getStrokeColor = function (group, key, data) {\n    var options = this.getOptions();\n    var defaultStrokeColor = Tools.getProperty(this.colorScale, group);\n\n    if (options.getStrokeColor) {\n      return options.getStrokeColor(group, key, data, defaultStrokeColor);\n    } else {\n      return defaultStrokeColor;\n    }\n  };\n\n  ChartModel.prototype.isUserProvidedColorScaleValid = function () {\n    var userProvidedScale = Tools.getProperty(this.getOptions(), 'color', 'scale');\n    var dataGroups = this.getDataGroups();\n\n    if (userProvidedScale == null || Object.keys(userProvidedScale).length == 0) {\n      return false;\n    }\n\n    return dataGroups.some(function (dataGroup) {\n      return Object.keys(userProvidedScale).includes(dataGroup.name);\n    });\n  };\n\n  ChartModel.prototype.getColorClassName = function (configs) {\n    var colorPairingTag = this.colorClassNames(configs.dataGroupName);\n    var className = configs.originalClassName;\n    configs.classNameTypes.forEach(function (type) {\n      return className = configs.originalClassName ? className + \" \" + type + \"-\" + colorPairingTag : type + \"-\" + colorPairingTag;\n    });\n    return className;\n  };\n  /**\n   * For charts that might hold an associated status for their dataset\n   */\n\n\n  ChartModel.prototype.getStatus = function () {\n    return null;\n  };\n\n  ChartModel.prototype.getAllDataGroupsNames = function () {\n    return this.allDataGroups;\n  };\n  /**\n   * Converts data provided in the older format to tabular\n   *\n   */\n\n\n  ChartModel.prototype.transformToTabularData = function (data) {\n    console.warn(\"We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/docs-tutorials--tabular-data-format\");\n    var tabularData = [];\n    var datasets = data.datasets,\n        labels = data.labels; // Loop through all datasets\n\n    datasets.forEach(function (dataset) {\n      // Update each data point to the new format\n      dataset.data.forEach(function (datum, i) {\n        var group;\n        var datasetLabel = Tools.getProperty(dataset, 'label');\n\n        if (datasetLabel === null) {\n          var correspondingLabel = Tools.getProperty(labels, i);\n\n          if (correspondingLabel) {\n            group = correspondingLabel;\n          } else {\n            group = 'Ungrouped';\n          }\n        } else {\n          group = datasetLabel;\n        }\n\n        var updatedDatum = {\n          group: group,\n          key: labels[i]\n        };\n\n        if (isNaN(datum)) {\n          updatedDatum['value'] = datum.value;\n          updatedDatum['date'] = datum.date;\n        } else {\n          updatedDatum['value'] = datum;\n        }\n\n        tabularData.push(updatedDatum);\n      });\n    });\n    return tabularData;\n  };\n\n  ChartModel.prototype.getTabularData = function (data) {\n    // if data is not an array\n    if (!Array.isArray(data)) {\n      return this.transformToTabularData(data);\n    }\n\n    return data;\n  };\n\n  ChartModel.prototype.sanitize = function (data) {\n    data = this.getTabularData(data);\n    return data;\n  };\n  /*\n   * Data groups\n   */\n\n\n  ChartModel.prototype.updateAllDataGroups = function () {\n    // allDataGroups is used to generate a color scale that applies\n    // to all the groups. Now when the data updates, you might remove a group,\n    // and then bring it back in a newer data update, therefore\n    // the order of the groups in allDataGroups matters so that you'd never\n    // have an incorrect color assigned to a group.\n    var _this = this; // Also, a new group should only be added to allDataGroups if\n    // it doesn't currently exist\n\n\n    if (!this.allDataGroups) {\n      this.allDataGroups = this.getDataGroupNames();\n    } else {\n      // Loop through current data groups\n      this.getDataGroupNames().forEach(function (dataGroupName) {\n        // If group name hasn't been stored yet, store it\n        if (_this.allDataGroups.indexOf(dataGroupName) === -1) {\n          _this.allDataGroups.push(dataGroupName);\n        }\n      });\n    }\n  };\n\n  ChartModel.prototype.generateDataGroups = function (data) {\n    var groupMapsTo = this.getOptions().data.groupMapsTo;\n    var _a = Configuration.legend.items.status,\n        ACTIVE = _a.ACTIVE,\n        DISABLED = _a.DISABLED;\n    var options = this.getOptions();\n    var uniqueDataGroups = map(data, function (datum) {\n      return datum[groupMapsTo];\n    }).keys(); // check if selectedGroups can be applied to chart with current data groups\n\n    if (options.data.selectedGroups.length) {\n      var hasAllSelectedGroups = options.data.selectedGroups.every(function (groupName) {\n        return uniqueDataGroups.includes(groupName);\n      });\n\n      if (!hasAllSelectedGroups) {\n        options.data.selectedGroups = [];\n      }\n    } // Get group status based on items in selected groups\n\n\n    var getStatus = function getStatus(groupName) {\n      return !options.data.selectedGroups.length || options.data.selectedGroups.includes(groupName) ? ACTIVE : DISABLED;\n    };\n\n    return uniqueDataGroups.map(function (groupName) {\n      return {\n        name: groupName,\n        status: getStatus(groupName)\n      };\n    });\n  };\n  /*\n   * Fill scales\n   */\n\n\n  ChartModel.prototype.setCustomColorScale = function () {\n    var _this = this;\n\n    if (!this.isUserProvidedColorScaleValid()) {\n      return;\n    }\n\n    var options = this.getOptions();\n    var userProvidedScale = Tools.getProperty(options, 'color', 'scale');\n    Object.keys(userProvidedScale).forEach(function (dataGroup) {\n      if (!_this.allDataGroups.includes(dataGroup)) {\n        console.warn(\"\\\"\" + dataGroup + \"\\\" does not exist in data groups.\");\n      }\n    });\n    /**\n     * Go through allDataGroups. If a data group has a color value provided\n     * by the user, add that to the color range\n     */\n\n    var providedDataGroups = this.allDataGroups.filter(function (dataGroup) {\n      return userProvidedScale[dataGroup];\n    });\n    providedDataGroups.forEach(function (dataGroup) {\n      return _this.colorScale[dataGroup] = userProvidedScale[dataGroup];\n    });\n  };\n  /*\n   * Color palette\n   */\n\n\n  ChartModel.prototype.setColorClassNames = function () {\n    var colorPairingOptions = Tools.getProperty(this.getOptions(), 'color', 'pairing'); // Check if user has defined numberOfVariants (differ from given data)\n\n    var numberOfVariants = Tools.getProperty(colorPairingOptions, 'numberOfVariants');\n\n    if (!numberOfVariants || numberOfVariants < this.allDataGroups.length) {\n      numberOfVariants = this.allDataGroups.length;\n    }\n\n    var pairingOption = Tools.getProperty(colorPairingOptions, 'option');\n    var colorPairingCounts = Configuration.color.pairingOptions; // If number of dataGroups is greater than 5, user 14-color palette\n\n    var numberOfColors = numberOfVariants > 5 ? 14 : numberOfVariants; // Use default palette if user choice is not in range\n\n    pairingOption = pairingOption <= colorPairingCounts[numberOfColors + \"-color\"] ? pairingOption : 1; // Create color classes for graph, tooltip and stroke use\n\n    var colorPairing = this.allDataGroups.map(function (dataGroup, index) {\n      return numberOfColors + \"-\" + pairingOption + \"-\" + (index % 14 + 1);\n    }); // Create default color classnames\n\n    this.colorClassNames = scaleOrdinal().range(colorPairing).domain(this.allDataGroups);\n  };\n\n  return ChartModel;\n}();\n\nexport { ChartModel };","map":{"version":3,"sources":["/Users/zander/Documents/Development/ActionsLogging/Dashboard/node_modules/@carbon/charts/model.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","Configuration","Tools","Events","ScaleTypes","map","scaleOrdinal","stack","ChartModel","services","state","options","colorScale","colorClassNames","getAllDataFromDomain","groups","getData","getOptions","allData","dataGroups","getDataGroups","groupMapsTo","getProperty","axesOptions","filter","item","includes","group","keys","forEach","axis","mapsTo","scaleType","LINEAR","LOG","datum","_a","Number","domain","LABELS","start_1","end_1","find","name","getDisplayData","get","ACTIVE","legend","items","status","data","allDataFromDomain","dataGroup","isDataEmpty","setData","newData","sanitizedData","sanitize","clone","generateDataGroups","set","isDataLoading","getActiveDataGroups","getDataGroupNames","getActiveDataGroupNames","activeDataGroups","getGroupedData","displayData","groupedData","undefined","push","groupName","getDataValuesGroupedByKeys","_this","stackKeys","domainIdentifier","cartesianScales","getDomainIdentifier","axisPosition","domainAxisPosition","axes","TIME","sort","a","b","dateA","Date","dateB","dataGroupNames","key","correspondingValues","sharedStackKey","dataGroupName","correspondingDatum","toString","rangeIdentifier","getRangeIdentifier","getStackedData","_b","percentage","_c","dataValuesGroupedByKeys","maxByKey_1","fromPairs","d","series","isNaN","element","newState","configs","newConfig","skipUpdate","animate","update","property","setOptions","newOptions","updateLegendAdditionalItems","merge","updateAllDataGroups","setCustomColorScale","setColorClassNames","events","dispatchEvent","Model","UPDATE","toggleDataLabel","changedLabel","DISABLED","hasDeactivatedItems","some","activeItems","indexToChange","findIndex","updatedActiveItems","hasUpdatedDeactivatedItems","selectedGroups","activeItem","Legend","ITEMS_UPDATE","getIsFilled","defaultFilled","getFillColor","defaultFillColor","getStrokeColor","defaultStrokeColor","isUserProvidedColorScaleValid","userProvidedScale","getColorClassName","colorPairingTag","className","originalClassName","classNameTypes","type","getStatus","getAllDataGroupsNames","allDataGroups","transformToTabularData","console","warn","tabularData","datasets","labels","dataset","datasetLabel","correspondingLabel","updatedDatum","value","date","getTabularData","Array","isArray","indexOf","uniqueDataGroups","hasAllSelectedGroups","every","providedDataGroups","colorPairingOptions","numberOfVariants","pairingOption","colorPairingCounts","color","pairingOptions","numberOfColors","colorPairing","index","range"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Internal Imports\nimport * as Configuration from './configuration';\nimport { Tools } from './tools';\nimport { Events, ScaleTypes } from './interfaces';\n// D3\nimport { map } from 'd3-collection';\nimport { scaleOrdinal } from 'd3-scale';\nimport { stack } from 'd3-shape';\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nvar ChartModel = /** @class */ (function () {\n    function ChartModel(services) {\n        // Internal Model state\n        this.state = {\n            options: {},\n        };\n        // Fill scales & fill related objects\n        this.colorScale = {};\n        this.colorClassNames = {};\n        this.services = services;\n    }\n    ChartModel.prototype.getAllDataFromDomain = function (groups) {\n        if (!this.getData()) {\n            return null;\n        }\n        var options = this.getOptions();\n        // Remove datasets that have been disabled\n        var allData = this.getData();\n        var dataGroups = this.getDataGroups();\n        var groupMapsTo = Tools.getProperty(options, 'data').groupMapsTo;\n        var axesOptions = Tools.getProperty(options, 'axes');\n        // filter out the groups that are irrelevant to the component\n        if (groups) {\n            allData = allData.filter(function (item) { return groups.includes(item.group); });\n        }\n        if (axesOptions) {\n            Object.keys(axesOptions).forEach(function (axis) {\n                var mapsTo = axesOptions[axis].mapsTo;\n                var scaleType = axesOptions[axis].scaleType;\n                // make sure linear/log values are numbers\n                if (scaleType === ScaleTypes.LINEAR ||\n                    scaleType === ScaleTypes.LOG) {\n                    allData = allData.map(function (datum) {\n                        var _a;\n                        return __assign(__assign({}, datum), (_a = {}, _a[mapsTo] = datum[mapsTo] === null\n                            ? datum[mapsTo]\n                            : Number(datum[mapsTo]), _a));\n                    });\n                }\n                // Check for custom domain\n                if (mapsTo && axesOptions[axis].domain) {\n                    if (scaleType === ScaleTypes.LABELS) {\n                        allData = allData.filter(function (datum) {\n                            return axesOptions[axis].domain.includes(datum[mapsTo]);\n                        });\n                    }\n                    else {\n                        var _a = axesOptions[axis].domain, start_1 = _a[0], end_1 = _a[1];\n                        // Filter out data outside domain if that datapoint is using that axis (has mapsTo property)\n                        allData = allData.filter(function (datum) {\n                            return !(mapsTo in datum) ||\n                                (datum[mapsTo] >= start_1 && datum[mapsTo] <= end_1);\n                        });\n                    }\n                }\n            });\n        }\n        return allData.filter(function (datum) {\n            return dataGroups.find(function (group) { return group.name === datum[groupMapsTo]; });\n        });\n    };\n    /**\n     * Charts that have group configs passed into them, only want to retrieve the display data relevant to that chart\n     * @param groups the included datasets for the particular chart\n     */\n    ChartModel.prototype.getDisplayData = function (groups) {\n        if (!this.get('data')) {\n            return null;\n        }\n        var ACTIVE = Configuration.legend.items.status.ACTIVE;\n        var dataGroups = this.getDataGroups(groups);\n        var groupMapsTo = this.getOptions().data.groupMapsTo;\n        var allDataFromDomain = this.getAllDataFromDomain(groups);\n        return allDataFromDomain.filter(function (datum) {\n            return dataGroups.find(function (dataGroup) {\n                return dataGroup.name === datum[groupMapsTo] &&\n                    dataGroup.status === ACTIVE;\n            });\n        });\n    };\n    ChartModel.prototype.getData = function () {\n        return this.get('data');\n    };\n    ChartModel.prototype.isDataEmpty = function () {\n        return !this.getData().length;\n    };\n    /**\n     *\n     * @param newData The new raw data to be set\n     */\n    ChartModel.prototype.setData = function (newData) {\n        var sanitizedData = this.sanitize(Tools.clone(newData));\n        var dataGroups = this.generateDataGroups(sanitizedData);\n        this.set({\n            data: sanitizedData,\n            dataGroups: dataGroups,\n        });\n        return sanitizedData;\n    };\n    ChartModel.prototype.getDataGroups = function (groups) {\n        var isDataLoading = Tools.getProperty(this.getOptions(), 'data', 'loading');\n        // No data should be displayed while data is still loading\n        if (isDataLoading) {\n            return [];\n        }\n        // if its a combo chart, the specific chart will pass the model the groups it needs\n        if (groups) {\n            return this.get('dataGroups').filter(function (dataGroup) {\n                return groups.includes(dataGroup.name);\n            });\n        }\n        return this.get('dataGroups');\n    };\n    ChartModel.prototype.getActiveDataGroups = function (groups) {\n        var ACTIVE = Configuration.legend.items.status.ACTIVE;\n        return this.getDataGroups(groups).filter(function (dataGroup) { return dataGroup.status === ACTIVE; });\n    };\n    ChartModel.prototype.getDataGroupNames = function (groups) {\n        var dataGroups = this.getDataGroups(groups);\n        return dataGroups.map(function (dataGroup) { return dataGroup.name; });\n    };\n    ChartModel.prototype.getActiveDataGroupNames = function (groups) {\n        var activeDataGroups = this.getActiveDataGroups(groups);\n        return activeDataGroups.map(function (dataGroup) { return dataGroup.name; });\n    };\n    ChartModel.prototype.getGroupedData = function (groups) {\n        var displayData = this.getDisplayData(groups);\n        var groupedData = {};\n        var groupMapsTo = this.getOptions().data.groupMapsTo;\n        displayData.map(function (datum) {\n            var group = datum[groupMapsTo];\n            if (groupedData[group] !== null &&\n                groupedData[group] !== undefined) {\n                groupedData[group].push(datum);\n            }\n            else {\n                groupedData[group] = [datum];\n            }\n        });\n        return Object.keys(groupedData).map(function (groupName) { return ({\n            name: groupName,\n            data: groupedData[groupName],\n        }); });\n    };\n    ChartModel.prototype.getDataValuesGroupedByKeys = function (groups) {\n        var _this = this;\n        var options = this.getOptions();\n        var groupMapsTo = options.data.groupMapsTo;\n        var displayData = this.getDisplayData(groups);\n        var stackKeys = map(displayData, function (datum) {\n            var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum);\n            return datum[domainIdentifier];\n        }).keys();\n        var axisPosition = this.services.cartesianScales.domainAxisPosition;\n        var scaleType = options.axes[axisPosition].scaleType;\n        // Sort keys\n        if (scaleType === ScaleTypes.TIME) {\n            stackKeys.sort(function (a, b) {\n                var dateA = new Date(a);\n                var dateB = new Date(b);\n                return dateA - dateB;\n            });\n        }\n        else if (scaleType === ScaleTypes.LOG ||\n            scaleType === ScaleTypes.LINEAR) {\n            stackKeys.sort(function (a, b) { return a - b; });\n        }\n        var dataGroupNames = this.getDataGroupNames();\n        return stackKeys.map(function (key) {\n            var correspondingValues = { sharedStackKey: key };\n            dataGroupNames.forEach(function (dataGroupName) {\n                var correspondingDatum = displayData.find(function (datum) {\n                    var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum);\n                    return (datum[groupMapsTo] === dataGroupName &&\n                        datum[domainIdentifier].toString() === key);\n                });\n                var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(correspondingValues);\n                correspondingValues[dataGroupName] = correspondingDatum\n                    ? correspondingDatum[rangeIdentifier]\n                    : null;\n            });\n            return correspondingValues;\n        });\n    };\n    ChartModel.prototype.getStackedData = function (_a) {\n        var _b = _a.percentage, percentage = _b === void 0 ? false : _b, _c = _a.groups, groups = _c === void 0 ? null : _c;\n        var options = this.getOptions();\n        var groupMapsTo = options.data.groupMapsTo;\n        var dataGroupNames = this.getDataGroupNames(groups);\n        var dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys(groups);\n        if (percentage) {\n            var maxByKey_1 = Tools.fromPairs(dataValuesGroupedByKeys.map(function (d) { return [d.sharedStackKey, 0]; }));\n            dataValuesGroupedByKeys.forEach(function (d) {\n                dataGroupNames.forEach(function (name) {\n                    maxByKey_1[d.sharedStackKey] += d[name];\n                });\n            });\n            // cycle through data values to get percentage\n            dataValuesGroupedByKeys.forEach(function (d) {\n                dataGroupNames.forEach(function (name) {\n                    if (maxByKey_1[d.sharedStackKey]) {\n                        d[name] = (d[name] / maxByKey_1[d.sharedStackKey]) * 100;\n                    }\n                    else {\n                        d[name] = 0;\n                    }\n                });\n            });\n        }\n        return stack()\n            .keys(dataGroupNames)(dataValuesGroupedByKeys)\n            .map(function (series, i) {\n            // Add data group names to each series\n            return Object.keys(series)\n                .filter(function (key) { return !isNaN(key); })\n                .map(function (key) {\n                var element = series[key];\n                element[groupMapsTo] = dataGroupNames[i];\n                return element;\n            });\n        });\n    };\n    /**\n     * @return {Object} The chart's options\n     */\n    ChartModel.prototype.getOptions = function () {\n        return this.state.options;\n    };\n    ChartModel.prototype.set = function (newState, configs) {\n        this.state = Object.assign({}, this.state, newState);\n        var newConfig = Object.assign({ skipUpdate: false, animate: true }, // default configs\n        configs);\n        if (!newConfig.skipUpdate) {\n            this.update(newConfig.animate);\n        }\n    };\n    ChartModel.prototype.get = function (property) {\n        if (property) {\n            return this.state[property];\n        }\n        else {\n            return this.state;\n        }\n    };\n    /**\n     *\n     * @param newOptions New options to be set\n     */\n    ChartModel.prototype.setOptions = function (newOptions) {\n        var options = this.getOptions();\n        Tools.updateLegendAdditionalItems(options, newOptions);\n        this.set({\n            options: Tools.merge(options, newOptions),\n        });\n    };\n    /**\n     *\n     * Updates miscellanous information within the model\n     * such as the color scales, or the legend data labels\n     */\n    ChartModel.prototype.update = function (animate) {\n        if (animate === void 0) { animate = true; }\n        if (!this.getDisplayData()) {\n            return;\n        }\n        this.updateAllDataGroups();\n        this.setCustomColorScale();\n        this.setColorClassNames();\n        this.services.events.dispatchEvent(Events.Model.UPDATE, { animate: animate });\n    };\n    /*\n     * Data labels\n     */\n    ChartModel.prototype.toggleDataLabel = function (changedLabel) {\n        var _a = Configuration.legend.items.status, ACTIVE = _a.ACTIVE, DISABLED = _a.DISABLED;\n        var dataGroups = this.getDataGroups();\n        var hasDeactivatedItems = dataGroups.some(function (group) { return group.status === DISABLED; });\n        var activeItems = dataGroups.filter(function (group) { return group.status === ACTIVE; });\n        // If there are deactivated items, toggle \"changedLabel\"\n        if (hasDeactivatedItems) {\n            // If the only active item is being toggled\n            // Activate all items\n            if (activeItems.length === 1 &&\n                activeItems[0].name === changedLabel) {\n                // If every item is active, then enable \"changedLabel\" and disable all other items\n                dataGroups.forEach(function (group, i) {\n                    dataGroups[i].status = ACTIVE;\n                });\n            }\n            else {\n                var indexToChange = dataGroups.findIndex(function (group) { return group.name === changedLabel; });\n                dataGroups[indexToChange].status =\n                    dataGroups[indexToChange].status === DISABLED\n                        ? ACTIVE\n                        : DISABLED;\n            }\n        }\n        else {\n            // If every item is active, then enable \"changedLabel\" and disable all other items\n            dataGroups.forEach(function (group, i) {\n                dataGroups[i].status =\n                    group.name === changedLabel ? ACTIVE : DISABLED;\n            });\n        }\n        // Updates selected groups\n        var updatedActiveItems = dataGroups.filter(function (group) { return group.status === ACTIVE; });\n        var options = this.getOptions();\n        var hasUpdatedDeactivatedItems = dataGroups.some(function (group) { return group.status === DISABLED; });\n        // If there are deactivated items, map the item name into selected groups\n        if (hasUpdatedDeactivatedItems) {\n            options.data.selectedGroups = updatedActiveItems.map(function (activeItem) { return activeItem.name; });\n        }\n        else {\n            // If every item is active, clear array\n            options.data.selectedGroups = [];\n        }\n        // dispatch legend filtering event with the status of all the dataLabels\n        this.services.events.dispatchEvent(Events.Legend.ITEMS_UPDATE, {\n            dataGroups: dataGroups,\n        });\n        // Update model\n        this.set({\n            dataGroups: dataGroups,\n        });\n    };\n    /**\n     * Should the data point be filled?\n     * @param group\n     * @param key\n     * @param value\n     * @param defaultFilled the default for this chart\n     */\n    ChartModel.prototype.getIsFilled = function (group, key, data, defaultFilled) {\n        var options = this.getOptions();\n        if (options.getIsFilled) {\n            return options.getIsFilled(group, key, data, defaultFilled);\n        }\n        else {\n            return defaultFilled;\n        }\n    };\n    ChartModel.prototype.getFillColor = function (group, key, data) {\n        var options = this.getOptions();\n        var defaultFillColor = Tools.getProperty(this.colorScale, group);\n        if (options.getFillColor) {\n            return options.getFillColor(group, key, data, defaultFillColor);\n        }\n        else {\n            return defaultFillColor;\n        }\n    };\n    ChartModel.prototype.getStrokeColor = function (group, key, data) {\n        var options = this.getOptions();\n        var defaultStrokeColor = Tools.getProperty(this.colorScale, group);\n        if (options.getStrokeColor) {\n            return options.getStrokeColor(group, key, data, defaultStrokeColor);\n        }\n        else {\n            return defaultStrokeColor;\n        }\n    };\n    ChartModel.prototype.isUserProvidedColorScaleValid = function () {\n        var userProvidedScale = Tools.getProperty(this.getOptions(), 'color', 'scale');\n        var dataGroups = this.getDataGroups();\n        if (userProvidedScale == null ||\n            Object.keys(userProvidedScale).length == 0) {\n            return false;\n        }\n        return dataGroups.some(function (dataGroup) {\n            return Object.keys(userProvidedScale).includes(dataGroup.name);\n        });\n    };\n    ChartModel.prototype.getColorClassName = function (configs) {\n        var colorPairingTag = this.colorClassNames(configs.dataGroupName);\n        var className = configs.originalClassName;\n        configs.classNameTypes.forEach(function (type) {\n            return (className = configs.originalClassName\n                ? className + \" \" + type + \"-\" + colorPairingTag\n                : type + \"-\" + colorPairingTag);\n        });\n        return className;\n    };\n    /**\n     * For charts that might hold an associated status for their dataset\n     */\n    ChartModel.prototype.getStatus = function () {\n        return null;\n    };\n    ChartModel.prototype.getAllDataGroupsNames = function () {\n        return this.allDataGroups;\n    };\n    /**\n     * Converts data provided in the older format to tabular\n     *\n     */\n    ChartModel.prototype.transformToTabularData = function (data) {\n        console.warn(\"We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/docs-tutorials--tabular-data-format\");\n        var tabularData = [];\n        var datasets = data.datasets, labels = data.labels;\n        // Loop through all datasets\n        datasets.forEach(function (dataset) {\n            // Update each data point to the new format\n            dataset.data.forEach(function (datum, i) {\n                var group;\n                var datasetLabel = Tools.getProperty(dataset, 'label');\n                if (datasetLabel === null) {\n                    var correspondingLabel = Tools.getProperty(labels, i);\n                    if (correspondingLabel) {\n                        group = correspondingLabel;\n                    }\n                    else {\n                        group = 'Ungrouped';\n                    }\n                }\n                else {\n                    group = datasetLabel;\n                }\n                var updatedDatum = {\n                    group: group,\n                    key: labels[i],\n                };\n                if (isNaN(datum)) {\n                    updatedDatum['value'] = datum.value;\n                    updatedDatum['date'] = datum.date;\n                }\n                else {\n                    updatedDatum['value'] = datum;\n                }\n                tabularData.push(updatedDatum);\n            });\n        });\n        return tabularData;\n    };\n    ChartModel.prototype.getTabularData = function (data) {\n        // if data is not an array\n        if (!Array.isArray(data)) {\n            return this.transformToTabularData(data);\n        }\n        return data;\n    };\n    ChartModel.prototype.sanitize = function (data) {\n        data = this.getTabularData(data);\n        return data;\n    };\n    /*\n     * Data groups\n     */\n    ChartModel.prototype.updateAllDataGroups = function () {\n        // allDataGroups is used to generate a color scale that applies\n        // to all the groups. Now when the data updates, you might remove a group,\n        // and then bring it back in a newer data update, therefore\n        // the order of the groups in allDataGroups matters so that you'd never\n        // have an incorrect color assigned to a group.\n        var _this = this;\n        // Also, a new group should only be added to allDataGroups if\n        // it doesn't currently exist\n        if (!this.allDataGroups) {\n            this.allDataGroups = this.getDataGroupNames();\n        }\n        else {\n            // Loop through current data groups\n            this.getDataGroupNames().forEach(function (dataGroupName) {\n                // If group name hasn't been stored yet, store it\n                if (_this.allDataGroups.indexOf(dataGroupName) === -1) {\n                    _this.allDataGroups.push(dataGroupName);\n                }\n            });\n        }\n    };\n    ChartModel.prototype.generateDataGroups = function (data) {\n        var groupMapsTo = this.getOptions().data.groupMapsTo;\n        var _a = Configuration.legend.items.status, ACTIVE = _a.ACTIVE, DISABLED = _a.DISABLED;\n        var options = this.getOptions();\n        var uniqueDataGroups = map(data, function (datum) { return datum[groupMapsTo]; }).keys();\n        // check if selectedGroups can be applied to chart with current data groups\n        if (options.data.selectedGroups.length) {\n            var hasAllSelectedGroups = options.data.selectedGroups.every(function (groupName) { return uniqueDataGroups.includes(groupName); });\n            if (!hasAllSelectedGroups) {\n                options.data.selectedGroups = [];\n            }\n        }\n        // Get group status based on items in selected groups\n        var getStatus = function (groupName) {\n            return !options.data.selectedGroups.length ||\n                options.data.selectedGroups.includes(groupName)\n                ? ACTIVE\n                : DISABLED;\n        };\n        return uniqueDataGroups.map(function (groupName) { return ({\n            name: groupName,\n            status: getStatus(groupName),\n        }); });\n    };\n    /*\n     * Fill scales\n     */\n    ChartModel.prototype.setCustomColorScale = function () {\n        var _this = this;\n        if (!this.isUserProvidedColorScaleValid()) {\n            return;\n        }\n        var options = this.getOptions();\n        var userProvidedScale = Tools.getProperty(options, 'color', 'scale');\n        Object.keys(userProvidedScale).forEach(function (dataGroup) {\n            if (!_this.allDataGroups.includes(dataGroup)) {\n                console.warn(\"\\\"\" + dataGroup + \"\\\" does not exist in data groups.\");\n            }\n        });\n        /**\n         * Go through allDataGroups. If a data group has a color value provided\n         * by the user, add that to the color range\n         */\n        var providedDataGroups = this.allDataGroups.filter(function (dataGroup) { return userProvidedScale[dataGroup]; });\n        providedDataGroups.forEach(function (dataGroup) {\n            return (_this.colorScale[dataGroup] = userProvidedScale[dataGroup]);\n        });\n    };\n    /*\n     * Color palette\n     */\n    ChartModel.prototype.setColorClassNames = function () {\n        var colorPairingOptions = Tools.getProperty(this.getOptions(), 'color', 'pairing');\n        // Check if user has defined numberOfVariants (differ from given data)\n        var numberOfVariants = Tools.getProperty(colorPairingOptions, 'numberOfVariants');\n        if (!numberOfVariants || numberOfVariants < this.allDataGroups.length) {\n            numberOfVariants = this.allDataGroups.length;\n        }\n        var pairingOption = Tools.getProperty(colorPairingOptions, 'option');\n        var colorPairingCounts = Configuration.color.pairingOptions;\n        // If number of dataGroups is greater than 5, user 14-color palette\n        var numberOfColors = numberOfVariants > 5 ? 14 : numberOfVariants;\n        // Use default palette if user choice is not in range\n        pairingOption =\n            pairingOption <= colorPairingCounts[numberOfColors + \"-color\"]\n                ? pairingOption\n                : 1;\n        // Create color classes for graph, tooltip and stroke use\n        var colorPairing = this.allDataGroups.map(function (dataGroup, index) {\n            return numberOfColors + \"-\" + pairingOption + \"-\" + ((index % 14) + 1);\n        });\n        // Create default color classnames\n        this.colorClassNames = scaleOrdinal()\n            .range(colorPairing)\n            .domain(this.allDataGroups);\n    };\n    return ChartModel;\n}());\nexport { ChartModel };\n//# sourceMappingURL=../src/model.js.map"]},"metadata":{},"sourceType":"module"}