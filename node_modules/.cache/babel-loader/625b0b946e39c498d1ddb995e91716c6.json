{"ast":null,"code":"import moment from 'moment';\nexport function getDictCount(dict, startDateStr, endDateStr) {\n  var startDate = moment(startDateStr, \"L\");\n  var endDate = moment(endDateStr, \"L\").endOf('day');\n  var keys = Object.keys(dict);\n  var count = 0;\n\n  for (var i = 0; i < keys.length; i++) {\n    var date = keys[i];\n    if (moment(date, \"L\").isBetween(startDate, endDate, \"day\", \"[]\")) count += dict[date];\n  }\n\n  return count;\n}\nexport function getUniqueUsers(dict, startDateStr, endDateStr) {\n  var startDate = moment(startDateStr, \"L\");\n  var endDate = moment(endDateStr, \"L\").endOf('day');\n  var keys = Object.keys(dict);\n  var count = 0;\n  var counted = [];\n\n  for (var i = 0; i < keys.length; i++) {\n    var date = keys[i];\n\n    if (moment(date, \"L\").isBetween(startDate, endDate, \"day\", \"[]\")) {\n      for (var j = 0; j < dict[date].users.length; j++) {\n        if (counted.indexOf(dict[date].users[j]) > -1) continue;\n        console.log(counted);\n        count += 1;\n        counted.push(dict[date].users[j]);\n      }\n    }\n  }\n\n  return count;\n}\nexport function getLayeredDictCount(dict, startDateStr, endDateStr) {\n  var startDate = moment(startDateStr, \"L\");\n  var endDate = moment(endDateStr, \"L\").endOf('day');\n  var ret = {};\n  var keys = Object.keys(dict);\n\n  for (var i = 0; i < keys.length; i++) {\n    var date = keys[i];\n\n    if (moment(date, \"L\").isBetween(startDate, endDate, \"day\", \"[]\")) {\n      var innerDict = dict[date];\n      var innerKeys = Object.keys(innerDict);\n\n      for (var j = 0; j < innerKeys.length; j++) {\n        var key = innerKeys[j];\n        ret[key] = key in ret ? ret[key] + innerDict[key] : innerDict[key];\n      }\n    }\n  }\n\n  return ret;\n}\nexport function mergePromptCountsByDate(promptStatus) {\n  var promptDateDict = {};\n  Object.keys(promptStatus).forEach(function (key) {\n    var _promptDateDict$date;\n\n    var date = key.split(\":::\")[0];\n    promptDateDict[date] = (_promptDateDict$date = promptDateDict[date]) !== null && _promptDateDict$date !== void 0 ? _promptDateDict$date : {\n      success: 0,\n      fail: 0\n    };\n    promptDateDict[date].success += promptStatus[key].success;\n    promptDateDict[date].fail += promptStatus[key].fail;\n  });\n  return promptDateDict;\n}","map":{"version":3,"sources":["/Users/zander/Documents/Development/ActionsLogging/Dashboard/src/utils.js"],"names":["moment","getDictCount","dict","startDateStr","endDateStr","startDate","endDate","endOf","keys","Object","count","i","length","date","isBetween","getUniqueUsers","counted","j","users","indexOf","console","log","push","getLayeredDictCount","ret","innerDict","innerKeys","key","mergePromptCountsByDate","promptStatus","promptDateDict","forEach","split","success","fail"],"mappings":"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","sourcesContent":["import moment from 'moment';\n\nexport function getDictCount(dict, startDateStr, endDateStr) {\n    let startDate = moment(startDateStr, \"L\")\n    let endDate = moment(endDateStr, \"L\").endOf('day');\n\n    let keys = Object.keys(dict)\n    let count = 0\n\n    for (let i = 0; i < keys.length; i++) {\n      let date = keys[i]\n\n      if (moment(date, \"L\").isBetween(startDate, endDate, \"day\", \"[]\"))\n        count += dict[date]\n    }\n\n    return count\n}\n\nexport function getUniqueUsers(dict, startDateStr, endDateStr) {\n    let startDate = moment(startDateStr, \"L\")\n    let endDate = moment(endDateStr, \"L\").endOf('day');\n\n    let keys = Object.keys(dict)\n    let count = 0\n    let counted = []\n\n    for (let i = 0; i < keys.length; i++) {\n        let date = keys[i]\n\n        if (moment(date, \"L\").isBetween(startDate, endDate, \"day\", \"[]\")) {\n            for (let j = 0; j < dict[date].users.length; j++) {\n                if (counted.indexOf(dict[date].users[j]) > -1) continue\n                \n                console.log(counted)\n                count += 1\n                counted.push(dict[date].users[j])\n            }\n        }\n    }\n\n    return count\n}\n\nexport function getLayeredDictCount(dict, startDateStr, endDateStr) {\n    let startDate = moment(startDateStr, \"L\")\n    let endDate = moment(endDateStr, \"L\").endOf('day');\n\n    let ret = {}\n    let keys = Object.keys(dict)\n\n    for (let i = 0; i < keys.length; i++) {\n      let date = keys[i]\n\n        if (moment(date, \"L\").isBetween(startDate, endDate, \"day\", \"[]\")) {\n            let innerDict = dict[date]\n            let innerKeys = Object.keys(innerDict)\n\n            for (let j = 0; j < innerKeys.length; j++) {\n                let key = innerKeys[j]\n                ret[key] = key in ret ? ret[key] + innerDict[key] : innerDict[key]\n            }\n        }\n    }\n\n    return ret\n}\n\nexport function mergePromptCountsByDate(promptStatus) {\n    let promptDateDict = {}\n    \n    Object.keys(promptStatus).forEach(key => {\n      let date = key.split(\":::\")[0]\n\n      promptDateDict[date] = promptDateDict[date] ?? { success: 0, fail: 0 }\n      promptDateDict[date].success += promptStatus[key].success\n      promptDateDict[date].fail += promptStatus[key].fail\n    })\n\n    return promptDateDict\n}"]},"metadata":{},"sourceType":"module"}