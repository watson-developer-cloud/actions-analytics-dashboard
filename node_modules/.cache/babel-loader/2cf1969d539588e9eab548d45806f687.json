{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}(); // Internal Imports\n\n\nimport { Component } from '../component';\nimport { Tools } from '../../tools';\nimport { DOMUtils } from '../../services'; // D3 Imports\n\nimport { axisBottom, axisLeft } from 'd3-axis';\n\nvar Grid =\n/** @class */\nfunction (_super) {\n  __extends(Grid, _super);\n\n  function Grid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'grid';\n    return _this;\n  }\n\n  Grid.prototype.render = function (animate) {\n    if (animate === void 0) {\n      animate = true;\n    }\n\n    var isXGridEnabled = Tools.getProperty(this.getOptions(), 'grid', 'x', 'enabled');\n    var isYGridEnabled = Tools.getProperty(this.getOptions(), 'grid', 'y', 'enabled'); // Draw the backdrop\n\n    this.drawBackdrop(isXGridEnabled, isYGridEnabled);\n\n    if (!isXGridEnabled && !isYGridEnabled) {\n      return;\n    }\n\n    if (isXGridEnabled) {\n      DOMUtils.appendOrSelect(this.backdrop, 'g.x.grid');\n      this.drawXGrid(animate);\n    }\n\n    if (isYGridEnabled) {\n      DOMUtils.appendOrSelect(this.backdrop, 'g.y.grid');\n      this.drawYGrid(animate);\n    }\n  };\n\n  Grid.prototype.drawXGrid = function (animate) {\n    var svg = this.parent;\n    var height = this.backdrop.attr('height');\n    var mainXScale = this.services.cartesianScales.getMainXScale();\n    var xGrid = axisBottom(mainXScale).tickSizeInner(-height).tickSizeOuter(0); // if the main range axis has a custom domain, align the gridlines to the ticks\n\n    var alignToTicks = Tools.getProperty(this.getOptions(), 'grid', 'x', 'alignWithAxisTicks');\n\n    if (alignToTicks) {\n      var mainXPosition = this.services.cartesianScales.getDomainAxisPosition();\n      var customDomain = Tools.getProperty(this.getOptions(), 'axes', mainXPosition, 'ticks', 'values'); // use custom domain if there is one\n      // otherwise d3 defaults to using one gridline per tick\n\n      if (customDomain) {\n        xGrid.tickValues(customDomain);\n      }\n    } else {\n      // Determine number of ticks\n      var numberOfTicks = Tools.getProperty(this.getOptions(), 'grid', 'x', 'numberOfTicks');\n      xGrid.ticks(numberOfTicks);\n    }\n\n    var g = svg.select('.x.grid').attr('transform', \"translate(\" + -this.backdrop.attr('x') + \", \" + height + \")\");\n\n    if (animate) {\n      var transition = this.services.transitions.getTransition('grid-update');\n      g.transition(transition).call(xGrid);\n    } else {\n      g.call(xGrid);\n    }\n\n    this.cleanGrid(g);\n  };\n\n  Grid.prototype.drawYGrid = function (animate) {\n    var svg = this.parent;\n    var width = this.backdrop.attr('width');\n    var mainYScale = this.services.cartesianScales.getMainYScale();\n    var yGrid = axisLeft(mainYScale).tickSizeInner(-width).tickSizeOuter(0); // if the main range axis has a custom domain, align the gridlines to the ticks\n\n    var alignToTicks = Tools.getProperty(this.getOptions(), 'grid', 'y', 'alignWithAxisTicks');\n\n    if (alignToTicks) {\n      var mainYPosition = this.services.cartesianScales.getRangeAxisPosition();\n      var customDomain = Tools.getProperty(this.getOptions(), 'axes', mainYPosition, 'ticks', 'values'); // use custom domain if there is one\n      // otherwise d3 defaults to using one gridline per tick\n\n      if (customDomain) {\n        yGrid.tickValues(customDomain);\n      }\n    } else {\n      // Determine number of ticks\n      var numberOfTicks = Tools.getProperty(this.getOptions(), 'grid', 'y', 'numberOfTicks');\n      yGrid.ticks(numberOfTicks);\n    }\n\n    var g = svg.select('.y.grid').attr('transform', \"translate(0, \" + -this.backdrop.attr('y') + \")\");\n\n    if (animate) {\n      var transition = this.services.transitions.getTransition('grid-update');\n      g.transition(transition).call(yGrid);\n    } else {\n      g.call(yGrid);\n    }\n\n    this.cleanGrid(g);\n  };\n  /**\n   * Returns the threshold for the gridline tooltips based on the mouse location.\n   * Calculated based on the mouse position between the two closest gridlines or edges of chart.\n   */\n\n\n  Grid.prototype.getGridlineThreshold = function (mousePos) {\n    // use the space between axis grid ticks to adjust the threshold for the tooltips\n    var svg = this.parent; // sort in ascending x translation value order\n\n    var gridlinesX = svg.selectAll('.x.grid .tick').nodes().sort(function (a, b) {\n      return Number(Tools.getTranslationValues(a).tx) - Number(Tools.getTranslationValues(b).tx);\n    }); // find the 2 gridlines on either side of the mouse\n\n    var floor = -1;\n    var ceiling;\n\n    if (!gridlinesX.length) {\n      return;\n    }\n\n    gridlinesX.forEach(function (line, i) {\n      if (mousePos[0] >= +Tools.getTranslationValues(line).tx) {\n        floor++;\n      }\n    });\n    ceiling = floor + 1 < gridlinesX.length ? floor + 1 : gridlinesX.length; // get the 'step' between chart gridlines\n\n    var line1 = gridlinesX[floor];\n    var line2 = gridlinesX[ceiling];\n    var lineSpacing; // if the mouse is on edge of charts (mouseX < first gridline || mouseX > last gridline)\n    // we can use the chart edge to determind the threshold for the gridlines\n\n    if (!line1) {\n      // we are between the first gridline and the chart edge\n      lineSpacing = +Tools.getTranslationValues(line2).tx;\n    } else if (!line2) {\n      // we need to use the chart right bounds in case there isnt a domain axis\n      var gridElement = svg.select('rect.chart-grid-backdrop').node();\n      var width = DOMUtils.getSVGElementSize(gridElement).width;\n      lineSpacing = width - +Tools.getTranslationValues(line1).tx;\n    } else {\n      // there are two gridlines to use\n      lineSpacing = +Tools.getTranslationValues(line2).tx - +Tools.getTranslationValues(line1).tx;\n    }\n\n    var threshold = this.getOptions().tooltip.gridline.threshold; // return the threshold\n\n    return lineSpacing * threshold;\n  };\n  /**\n   * Returns the active gridlines based on the gridline threshold and mouse position.\n   * @param position mouse positon\n   */\n\n\n  Grid.prototype.getActiveGridline = function (position) {\n    var userSpecifiedThreshold = Tools.getProperty(this.getOptions, 'tooltip', 'gridline', 'threshold');\n    var threshold = userSpecifiedThreshold ? userSpecifiedThreshold : this.getGridlineThreshold(position);\n    var svg = this.parent;\n    var xGridlines = svg.selectAll('.x.grid .tick').filter(function () {\n      var translations = Tools.getTranslationValues(this); // threshold for when to display a gridline tooltip\n\n      var bounds = {\n        min: Number(translations.tx) - threshold,\n        max: Number(translations.tx) + threshold\n      };\n      return bounds.min <= position[0] && position[0] <= bounds.max;\n    });\n    return xGridlines;\n  };\n\n  Grid.prototype.drawBackdrop = function (isXGridEnabled, isYGridEnabled) {\n    var svg = this.parent;\n    var mainXScale = this.services.cartesianScales.getMainXScale();\n    var mainYScale = this.services.cartesianScales.getMainYScale();\n\n    var _a = mainXScale.range(),\n        xScaleStart = _a[0],\n        xScaleEnd = _a[1];\n\n    var _b = mainYScale.range(),\n        yScaleEnd = _b[0],\n        yScaleStart = _b[1]; // Get height from the grid\n\n\n    this.backdrop = DOMUtils.appendOrSelect(svg, 'svg.chart-grid-backdrop');\n    var backdropRect = DOMUtils.appendOrSelect(this.backdrop, isXGridEnabled || isYGridEnabled ? 'rect.chart-grid-backdrop.stroked' : 'rect.chart-grid-backdrop');\n    this.backdrop.merge(backdropRect).attr('x', xScaleStart).attr('y', yScaleStart).attr('width', Math.abs(xScaleEnd - xScaleStart)).attr('height', Math.abs(yScaleEnd - yScaleStart)).lower();\n    backdropRect.attr('width', '100%').attr('height', '100%');\n  };\n\n  Grid.prototype.cleanGrid = function (g) {\n    // Remove extra elements\n    g.selectAll('text').remove();\n    g.select('.domain').remove();\n  };\n\n  return Grid;\n}(Component);\n\nexport { Grid };","map":{"version":3,"sources":["/Users/zander/Documents/Development/ActionsLogging/Dashboard/node_modules/@carbon/charts/components/axes/grid.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Component","Tools","DOMUtils","axisBottom","axisLeft","Grid","_super","_this","apply","arguments","type","render","animate","isXGridEnabled","getProperty","getOptions","isYGridEnabled","drawBackdrop","appendOrSelect","backdrop","drawXGrid","drawYGrid","svg","parent","height","attr","mainXScale","services","cartesianScales","getMainXScale","xGrid","tickSizeInner","tickSizeOuter","alignToTicks","mainXPosition","getDomainAxisPosition","customDomain","tickValues","numberOfTicks","ticks","g","select","transition","transitions","getTransition","call","cleanGrid","width","mainYScale","getMainYScale","yGrid","mainYPosition","getRangeAxisPosition","getGridlineThreshold","mousePos","gridlinesX","selectAll","nodes","sort","a","Number","getTranslationValues","tx","floor","ceiling","length","forEach","line","i","line1","line2","lineSpacing","gridElement","node","getSVGElementSize","threshold","tooltip","gridline","getActiveGridline","position","userSpecifiedThreshold","xGridlines","filter","translations","bounds","min","max","_a","range","xScaleStart","xScaleEnd","_b","yScaleEnd","yScaleStart","backdropRect","merge","Math","abs","lower","remove"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n// Internal Imports\nimport { Component } from '../component';\nimport { Tools } from '../../tools';\nimport { DOMUtils } from '../../services';\n// D3 Imports\nimport { axisBottom, axisLeft } from 'd3-axis';\nvar Grid = /** @class */ (function (_super) {\n    __extends(Grid, _super);\n    function Grid() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'grid';\n        return _this;\n    }\n    Grid.prototype.render = function (animate) {\n        if (animate === void 0) { animate = true; }\n        var isXGridEnabled = Tools.getProperty(this.getOptions(), 'grid', 'x', 'enabled');\n        var isYGridEnabled = Tools.getProperty(this.getOptions(), 'grid', 'y', 'enabled');\n        // Draw the backdrop\n        this.drawBackdrop(isXGridEnabled, isYGridEnabled);\n        if (!isXGridEnabled && !isYGridEnabled) {\n            return;\n        }\n        if (isXGridEnabled) {\n            DOMUtils.appendOrSelect(this.backdrop, 'g.x.grid');\n            this.drawXGrid(animate);\n        }\n        if (isYGridEnabled) {\n            DOMUtils.appendOrSelect(this.backdrop, 'g.y.grid');\n            this.drawYGrid(animate);\n        }\n    };\n    Grid.prototype.drawXGrid = function (animate) {\n        var svg = this.parent;\n        var height = this.backdrop.attr('height');\n        var mainXScale = this.services.cartesianScales.getMainXScale();\n        var xGrid = axisBottom(mainXScale)\n            .tickSizeInner(-height)\n            .tickSizeOuter(0);\n        // if the main range axis has a custom domain, align the gridlines to the ticks\n        var alignToTicks = Tools.getProperty(this.getOptions(), 'grid', 'x', 'alignWithAxisTicks');\n        if (alignToTicks) {\n            var mainXPosition = this.services.cartesianScales.getDomainAxisPosition();\n            var customDomain = Tools.getProperty(this.getOptions(), 'axes', mainXPosition, 'ticks', 'values');\n            // use custom domain if there is one\n            // otherwise d3 defaults to using one gridline per tick\n            if (customDomain) {\n                xGrid.tickValues(customDomain);\n            }\n        }\n        else {\n            // Determine number of ticks\n            var numberOfTicks = Tools.getProperty(this.getOptions(), 'grid', 'x', 'numberOfTicks');\n            xGrid.ticks(numberOfTicks);\n        }\n        var g = svg\n            .select('.x.grid')\n            .attr('transform', \"translate(\" + -this.backdrop.attr('x') + \", \" + height + \")\");\n        if (animate) {\n            var transition = this.services.transitions.getTransition('grid-update');\n            g.transition(transition).call(xGrid);\n        }\n        else {\n            g.call(xGrid);\n        }\n        this.cleanGrid(g);\n    };\n    Grid.prototype.drawYGrid = function (animate) {\n        var svg = this.parent;\n        var width = this.backdrop.attr('width');\n        var mainYScale = this.services.cartesianScales.getMainYScale();\n        var yGrid = axisLeft(mainYScale)\n            .tickSizeInner(-width)\n            .tickSizeOuter(0);\n        // if the main range axis has a custom domain, align the gridlines to the ticks\n        var alignToTicks = Tools.getProperty(this.getOptions(), 'grid', 'y', 'alignWithAxisTicks');\n        if (alignToTicks) {\n            var mainYPosition = this.services.cartesianScales.getRangeAxisPosition();\n            var customDomain = Tools.getProperty(this.getOptions(), 'axes', mainYPosition, 'ticks', 'values');\n            // use custom domain if there is one\n            // otherwise d3 defaults to using one gridline per tick\n            if (customDomain) {\n                yGrid.tickValues(customDomain);\n            }\n        }\n        else {\n            // Determine number of ticks\n            var numberOfTicks = Tools.getProperty(this.getOptions(), 'grid', 'y', 'numberOfTicks');\n            yGrid.ticks(numberOfTicks);\n        }\n        var g = svg\n            .select('.y.grid')\n            .attr('transform', \"translate(0, \" + -this.backdrop.attr('y') + \")\");\n        if (animate) {\n            var transition = this.services.transitions.getTransition('grid-update');\n            g.transition(transition).call(yGrid);\n        }\n        else {\n            g.call(yGrid);\n        }\n        this.cleanGrid(g);\n    };\n    /**\n     * Returns the threshold for the gridline tooltips based on the mouse location.\n     * Calculated based on the mouse position between the two closest gridlines or edges of chart.\n     */\n    Grid.prototype.getGridlineThreshold = function (mousePos) {\n        // use the space between axis grid ticks to adjust the threshold for the tooltips\n        var svg = this.parent;\n        // sort in ascending x translation value order\n        var gridlinesX = svg\n            .selectAll('.x.grid .tick')\n            .nodes()\n            .sort(function (a, b) {\n            return (Number(Tools.getTranslationValues(a).tx) -\n                Number(Tools.getTranslationValues(b).tx));\n        });\n        // find the 2 gridlines on either side of the mouse\n        var floor = -1;\n        var ceiling;\n        if (!gridlinesX.length) {\n            return;\n        }\n        gridlinesX.forEach(function (line, i) {\n            if (mousePos[0] >= +Tools.getTranslationValues(line).tx) {\n                floor++;\n            }\n        });\n        ceiling = floor + 1 < gridlinesX.length ? floor + 1 : gridlinesX.length;\n        // get the 'step' between chart gridlines\n        var line1 = gridlinesX[floor];\n        var line2 = gridlinesX[ceiling];\n        var lineSpacing;\n        // if the mouse is on edge of charts (mouseX < first gridline || mouseX > last gridline)\n        // we can use the chart edge to determind the threshold for the gridlines\n        if (!line1) {\n            // we are between the first gridline and the chart edge\n            lineSpacing = +Tools.getTranslationValues(line2).tx;\n        }\n        else if (!line2) {\n            // we need to use the chart right bounds in case there isnt a domain axis\n            var gridElement = svg.select('rect.chart-grid-backdrop').node();\n            var width = DOMUtils.getSVGElementSize(gridElement).width;\n            lineSpacing = width - +Tools.getTranslationValues(line1).tx;\n        }\n        else {\n            // there are two gridlines to use\n            lineSpacing =\n                +Tools.getTranslationValues(line2).tx -\n                    +Tools.getTranslationValues(line1).tx;\n        }\n        var threshold = this.getOptions().tooltip.gridline.threshold;\n        // return the threshold\n        return lineSpacing * threshold;\n    };\n    /**\n     * Returns the active gridlines based on the gridline threshold and mouse position.\n     * @param position mouse positon\n     */\n    Grid.prototype.getActiveGridline = function (position) {\n        var userSpecifiedThreshold = Tools.getProperty(this.getOptions, 'tooltip', 'gridline', 'threshold');\n        var threshold = userSpecifiedThreshold\n            ? userSpecifiedThreshold\n            : this.getGridlineThreshold(position);\n        var svg = this.parent;\n        var xGridlines = svg.selectAll('.x.grid .tick').filter(function () {\n            var translations = Tools.getTranslationValues(this);\n            // threshold for when to display a gridline tooltip\n            var bounds = {\n                min: Number(translations.tx) - threshold,\n                max: Number(translations.tx) + threshold,\n            };\n            return bounds.min <= position[0] && position[0] <= bounds.max;\n        });\n        return xGridlines;\n    };\n    Grid.prototype.drawBackdrop = function (isXGridEnabled, isYGridEnabled) {\n        var svg = this.parent;\n        var mainXScale = this.services.cartesianScales.getMainXScale();\n        var mainYScale = this.services.cartesianScales.getMainYScale();\n        var _a = mainXScale.range(), xScaleStart = _a[0], xScaleEnd = _a[1];\n        var _b = mainYScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];\n        // Get height from the grid\n        this.backdrop = DOMUtils.appendOrSelect(svg, 'svg.chart-grid-backdrop');\n        var backdropRect = DOMUtils.appendOrSelect(this.backdrop, isXGridEnabled || isYGridEnabled\n            ? 'rect.chart-grid-backdrop.stroked'\n            : 'rect.chart-grid-backdrop');\n        this.backdrop\n            .merge(backdropRect)\n            .attr('x', xScaleStart)\n            .attr('y', yScaleStart)\n            .attr('width', Math.abs(xScaleEnd - xScaleStart))\n            .attr('height', Math.abs(yScaleEnd - yScaleStart))\n            .lower();\n        backdropRect.attr('width', '100%').attr('height', '100%');\n    };\n    Grid.prototype.cleanGrid = function (g) {\n        // Remove extra elements\n        g.selectAll('text').remove();\n        g.select('.domain').remove();\n    };\n    return Grid;\n}(Component));\nexport { Grid };\n//# sourceMappingURL=../../../src/components/axes/grid.js.map"]},"metadata":{},"sourceType":"module"}