{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}(); // Internal Imports\n\n\nimport { Component } from '../component';\nimport { DOMUtils } from '../../services';\nimport { CartesianOrientations, Events } from '../../interfaces';\nimport { Tools } from '../../tools'; // D3 Imports\n\nimport { mouse } from 'd3-selection';\nvar THRESHOLD = 5;\n/** check if x is inside threshold area extents  */\n\nfunction pointIsWithinThreshold(dx, x) {\n  return dx > x - THRESHOLD && dx < x + THRESHOLD;\n}\n\nvar Ruler =\n/** @class */\nfunction (_super) {\n  __extends(Ruler, _super);\n\n  function Ruler() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'ruler';\n    _this.isXGridEnabled = Tools.getProperty(_this.getOptions(), 'grid', 'x', 'enabled');\n    _this.isYGridEnabled = Tools.getProperty(_this.getOptions(), 'grid', 'y', 'enabled'); // flag for checking whether ruler event listener is added or not\n\n    _this.isEventListenerAdded = false;\n    return _this;\n  }\n\n  Ruler.prototype.render = function () {\n    var isRulerEnabled = Tools.getProperty(this.getOptions(), 'ruler', 'enabled');\n    this.drawBackdrop();\n\n    if (isRulerEnabled && !this.isEventListenerAdded) {\n      this.addBackdropEventListeners();\n    } else if (!isRulerEnabled && this.isEventListenerAdded) {\n      this.removeBackdropEventListeners();\n    }\n  };\n\n  Ruler.prototype.removeBackdropEventListeners = function () {\n    this.isEventListenerAdded = false;\n    this.backdrop.on('mousemove mouseover mouseout', null);\n  };\n\n  Ruler.prototype.formatTooltipData = function (tooltipData) {\n    return tooltipData;\n  };\n\n  Ruler.prototype.showRuler = function (_a) {\n    var _this = this;\n\n    var x = _a[0],\n        y = _a[1];\n    var svg = this.parent;\n    var orientation = this.services.cartesianScales.getOrientation();\n    var mouseCoordinate = orientation === CartesianOrientations.HORIZONTAL ? y : x;\n    var ruler = DOMUtils.appendOrSelect(svg, 'g.ruler').attr('aria-label', 'ruler');\n    var rulerLine = DOMUtils.appendOrSelect(ruler, 'line.ruler-line');\n    var dataPointElements = svg.selectAll('[role=graphics-symbol]');\n    var displayData = this.model.getDisplayData();\n    var rangeScale = this.services.cartesianScales.getRangeScale();\n\n    var _b = rangeScale.range(),\n        yScaleEnd = _b[0],\n        yScaleStart = _b[1];\n\n    var pointsWithinLine = displayData.map(function (d) {\n      return {\n        domainValue: _this.services.cartesianScales.getDomainValue(d),\n        originalData: d\n      };\n    }).filter(function (d) {\n      return pointIsWithinThreshold(d.domainValue, mouseCoordinate);\n    });\n\n    if (this.pointsWithinLine && pointsWithinLine.length === this.pointsWithinLine.length && pointsWithinLine.map(function (point) {\n      return point.domainValue;\n    }).join() === this.pointsWithinLine.map(function (point) {\n      return point.domainValue;\n    }).join()) {\n      this.pointsWithinLine = pointsWithinLine;\n      return this.services.events.dispatchEvent(Events.Tooltip.MOVE, {\n        mousePosition: [x, y]\n      });\n    }\n\n    this.pointsWithinLine = pointsWithinLine;\n    /**\n     * Find matches, reduce is used instead of filter\n     * to only get elements which belong to the same axis coordinate\n     */\n\n    var dataPointsMatchingRulerLine = this.pointsWithinLine.reduce(function (accum, currentValue) {\n      if (accum.length === 0) {\n        accum.push(currentValue);\n        return accum;\n      } // store the first element of the accumulator array to compare it with current element being processed\n\n\n      var sampleAccumValue = accum[0].domainValue;\n      var distanceToCurrentValue = Math.abs(mouseCoordinate - currentValue.domainValue);\n      var distanceToAccumValue = Math.abs(mouseCoordinate - sampleAccumValue);\n\n      if (distanceToCurrentValue > distanceToAccumValue) {\n        // if distance with current value is bigger than already existing value in the accumulator, skip current iteration\n        return accum;\n      } else if (distanceToCurrentValue < distanceToAccumValue) {\n        // currentValue data point is closer to mouse inside the threshold area, so reinstantiate array\n        accum = [currentValue];\n      } else {\n        // currentValue is equal to already stored values, which means there's another match on the same coordinate\n        accum.push(currentValue);\n      }\n\n      return accum;\n    }, []); // some data point match\n\n    if (dataPointsMatchingRulerLine.length > 0) {\n      var tooltipData = dataPointsMatchingRulerLine.map(function (d) {\n        return d.originalData;\n      }).filter(function (d) {\n        var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(d);\n\n        var value = d[rangeIdentifier];\n        return value !== null && value !== undefined;\n      }); // get elements on which we should trigger mouse events\n\n      var domainValuesMatchingRulerLine_1 = dataPointsMatchingRulerLine.map(function (d) {\n        return d.domainValue;\n      });\n      var elementsToHighlight = dataPointElements.filter(function (d) {\n        var domainValue = _this.services.cartesianScales.getDomainValue(d);\n\n        return domainValuesMatchingRulerLine_1.includes(domainValue);\n      });\n      /** if we pass from a trigger area to another one\n       * mouseout on previous elements won't get dispatched\n       * so we need to do it manually\n       */\n\n      if (this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Tools.isEqual(this.elementsToHighlight, elementsToHighlight)) {\n        this.hideRuler();\n      }\n\n      elementsToHighlight.dispatch('mouseover'); // set current hovered elements\n\n      this.elementsToHighlight = elementsToHighlight;\n      this.services.events.dispatchEvent(Events.Tooltip.SHOW, {\n        mousePosition: [x, y],\n        hoveredElement: rulerLine,\n        data: this.formatTooltipData(tooltipData)\n      });\n      ruler.attr('opacity', 1); // line snaps to matching point\n\n      var sampleMatch = dataPointsMatchingRulerLine[0];\n\n      if (orientation === 'horizontal') {\n        rulerLine.attr('x1', yScaleStart).attr('x2', yScaleEnd).attr('y1', sampleMatch.domainValue).attr('y2', sampleMatch.domainValue);\n      } else {\n        rulerLine.attr('y1', yScaleStart).attr('y2', yScaleEnd).attr('x1', sampleMatch.domainValue).attr('x2', sampleMatch.domainValue);\n      }\n    } else {\n      this.hideRuler();\n    }\n  };\n\n  Ruler.prototype.hideRuler = function () {\n    var svg = this.parent;\n    var ruler = DOMUtils.appendOrSelect(svg, 'g.ruler');\n    var dataPointElements = svg.selectAll('[role=graphics-symbol]');\n    dataPointElements.dispatch('mouseout');\n    this.services.events.dispatchEvent(Events.Tooltip.HIDE);\n    ruler.attr('opacity', 0);\n  };\n  /**\n   * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.\n   */\n\n\n  Ruler.prototype.addBackdropEventListeners = function () {\n    this.isEventListenerAdded = true;\n    var self = this;\n    var displayData = this.model.getDisplayData();\n\n    var mouseMoveCallback = function mouseMoveCallback() {\n      var pos = mouse(self.parent.node());\n      self.showRuler(pos);\n    }; // Debounce mouseMoveCallback if there are more than 100 datapoints\n\n\n    if (displayData.length > 100) {\n      var debounceThreshold = displayData.length % 50 * 12.5;\n      mouseMoveCallback = Tools.debounceWithD3MousePosition(function () {\n        var mousePosition = this.mousePosition;\n        self.showRuler(mousePosition);\n      }, debounceThreshold, this.parent.node());\n    }\n\n    this.backdrop.on('mousemove mouseover', mouseMoveCallback).on('mouseout', this.hideRuler.bind(this));\n  };\n\n  Ruler.prototype.drawBackdrop = function () {\n    var svg = this.parent;\n    var mainXScale = this.services.cartesianScales.getMainXScale();\n    var mainYScale = this.services.cartesianScales.getMainYScale();\n\n    var _a = mainXScale.range(),\n        xScaleStart = _a[0],\n        xScaleEnd = _a[1];\n\n    var _b = mainYScale.range(),\n        yScaleEnd = _b[0],\n        yScaleStart = _b[1]; // Get height from the grid\n\n\n    this.backdrop = DOMUtils.appendOrSelect(svg, 'svg.chart-grid-backdrop');\n    var backdropRect = DOMUtils.appendOrSelect(this.backdrop, this.isXGridEnabled || this.isYGridEnabled ? 'rect.chart-grid-backdrop.stroked' : 'rect.chart-grid-backdrop');\n  };\n\n  return Ruler;\n}(Component);\n\nexport { Ruler };","map":{"version":3,"sources":["/Users/zander/Documents/Development/ActionsLogging/Dashboard/node_modules/@carbon/charts/components/axes/ruler.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Component","DOMUtils","CartesianOrientations","Events","Tools","mouse","THRESHOLD","pointIsWithinThreshold","dx","x","Ruler","_super","_this","apply","arguments","type","isXGridEnabled","getProperty","getOptions","isYGridEnabled","isEventListenerAdded","render","isRulerEnabled","drawBackdrop","addBackdropEventListeners","removeBackdropEventListeners","backdrop","on","formatTooltipData","tooltipData","showRuler","_a","y","svg","parent","orientation","services","cartesianScales","getOrientation","mouseCoordinate","HORIZONTAL","ruler","appendOrSelect","attr","rulerLine","dataPointElements","selectAll","displayData","model","getDisplayData","rangeScale","getRangeScale","_b","range","yScaleEnd","yScaleStart","pointsWithinLine","map","domainValue","getDomainValue","originalData","filter","length","point","join","events","dispatchEvent","Tooltip","MOVE","mousePosition","dataPointsMatchingRulerLine","reduce","accum","currentValue","push","sampleAccumValue","distanceToCurrentValue","Math","abs","distanceToAccumValue","rangeIdentifier","getRangeIdentifier","value","undefined","domainValuesMatchingRulerLine_1","elementsToHighlight","includes","size","isEqual","hideRuler","dispatch","SHOW","hoveredElement","data","sampleMatch","HIDE","self","mouseMoveCallback","pos","node","debounceThreshold","debounceWithD3MousePosition","bind","mainXScale","getMainXScale","mainYScale","getMainYScale","xScaleStart","xScaleEnd","backdropRect"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n// Internal Imports\nimport { Component } from '../component';\nimport { DOMUtils } from '../../services';\nimport { CartesianOrientations, Events } from '../../interfaces';\nimport { Tools } from '../../tools';\n// D3 Imports\nimport { mouse } from 'd3-selection';\nvar THRESHOLD = 5;\n/** check if x is inside threshold area extents  */\nfunction pointIsWithinThreshold(dx, x) {\n    return dx > x - THRESHOLD && dx < x + THRESHOLD;\n}\nvar Ruler = /** @class */ (function (_super) {\n    __extends(Ruler, _super);\n    function Ruler() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'ruler';\n        _this.isXGridEnabled = Tools.getProperty(_this.getOptions(), 'grid', 'x', 'enabled');\n        _this.isYGridEnabled = Tools.getProperty(_this.getOptions(), 'grid', 'y', 'enabled');\n        // flag for checking whether ruler event listener is added or not\n        _this.isEventListenerAdded = false;\n        return _this;\n    }\n    Ruler.prototype.render = function () {\n        var isRulerEnabled = Tools.getProperty(this.getOptions(), 'ruler', 'enabled');\n        this.drawBackdrop();\n        if (isRulerEnabled && !this.isEventListenerAdded) {\n            this.addBackdropEventListeners();\n        }\n        else if (!isRulerEnabled && this.isEventListenerAdded) {\n            this.removeBackdropEventListeners();\n        }\n    };\n    Ruler.prototype.removeBackdropEventListeners = function () {\n        this.isEventListenerAdded = false;\n        this.backdrop.on('mousemove mouseover mouseout', null);\n    };\n    Ruler.prototype.formatTooltipData = function (tooltipData) {\n        return tooltipData;\n    };\n    Ruler.prototype.showRuler = function (_a) {\n        var _this = this;\n        var x = _a[0], y = _a[1];\n        var svg = this.parent;\n        var orientation = this.services.cartesianScales.getOrientation();\n        var mouseCoordinate = orientation === CartesianOrientations.HORIZONTAL ? y : x;\n        var ruler = DOMUtils.appendOrSelect(svg, 'g.ruler').attr('aria-label', 'ruler');\n        var rulerLine = DOMUtils.appendOrSelect(ruler, 'line.ruler-line');\n        var dataPointElements = svg.selectAll('[role=graphics-symbol]');\n        var displayData = this.model.getDisplayData();\n        var rangeScale = this.services.cartesianScales.getRangeScale();\n        var _b = rangeScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];\n        var pointsWithinLine = displayData\n            .map(function (d) { return ({\n            domainValue: _this.services.cartesianScales.getDomainValue(d),\n            originalData: d,\n        }); })\n            .filter(function (d) {\n            return pointIsWithinThreshold(d.domainValue, mouseCoordinate);\n        });\n        if (this.pointsWithinLine &&\n            pointsWithinLine.length === this.pointsWithinLine.length &&\n            pointsWithinLine.map(function (point) { return point.domainValue; }).join() ===\n                this.pointsWithinLine.map(function (point) { return point.domainValue; }).join()) {\n            this.pointsWithinLine = pointsWithinLine;\n            return this.services.events.dispatchEvent(Events.Tooltip.MOVE, {\n                mousePosition: [x, y],\n            });\n        }\n        this.pointsWithinLine = pointsWithinLine;\n        /**\n         * Find matches, reduce is used instead of filter\n         * to only get elements which belong to the same axis coordinate\n         */\n        var dataPointsMatchingRulerLine = this.pointsWithinLine.reduce(function (accum, currentValue) {\n            if (accum.length === 0) {\n                accum.push(currentValue);\n                return accum;\n            }\n            // store the first element of the accumulator array to compare it with current element being processed\n            var sampleAccumValue = accum[0].domainValue;\n            var distanceToCurrentValue = Math.abs(mouseCoordinate - currentValue.domainValue);\n            var distanceToAccumValue = Math.abs(mouseCoordinate - sampleAccumValue);\n            if (distanceToCurrentValue > distanceToAccumValue) {\n                // if distance with current value is bigger than already existing value in the accumulator, skip current iteration\n                return accum;\n            }\n            else if (distanceToCurrentValue < distanceToAccumValue) {\n                // currentValue data point is closer to mouse inside the threshold area, so reinstantiate array\n                accum = [currentValue];\n            }\n            else {\n                // currentValue is equal to already stored values, which means there's another match on the same coordinate\n                accum.push(currentValue);\n            }\n            return accum;\n        }, []);\n        // some data point match\n        if (dataPointsMatchingRulerLine.length > 0) {\n            var tooltipData = dataPointsMatchingRulerLine\n                .map(function (d) { return d.originalData; })\n                .filter(function (d) {\n                var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(d);\n                var value = d[rangeIdentifier];\n                return value !== null && value !== undefined;\n            });\n            // get elements on which we should trigger mouse events\n            var domainValuesMatchingRulerLine_1 = dataPointsMatchingRulerLine.map(function (d) { return d.domainValue; });\n            var elementsToHighlight = dataPointElements.filter(function (d) {\n                var domainValue = _this.services.cartesianScales.getDomainValue(d);\n                return domainValuesMatchingRulerLine_1.includes(domainValue);\n            });\n            /** if we pass from a trigger area to another one\n             * mouseout on previous elements won't get dispatched\n             * so we need to do it manually\n             */\n            if (this.elementsToHighlight &&\n                this.elementsToHighlight.size() > 0 &&\n                !Tools.isEqual(this.elementsToHighlight, elementsToHighlight)) {\n                this.hideRuler();\n            }\n            elementsToHighlight.dispatch('mouseover');\n            // set current hovered elements\n            this.elementsToHighlight = elementsToHighlight;\n            this.services.events.dispatchEvent(Events.Tooltip.SHOW, {\n                mousePosition: [x, y],\n                hoveredElement: rulerLine,\n                data: this.formatTooltipData(tooltipData),\n            });\n            ruler.attr('opacity', 1);\n            // line snaps to matching point\n            var sampleMatch = dataPointsMatchingRulerLine[0];\n            if (orientation === 'horizontal') {\n                rulerLine\n                    .attr('x1', yScaleStart)\n                    .attr('x2', yScaleEnd)\n                    .attr('y1', sampleMatch.domainValue)\n                    .attr('y2', sampleMatch.domainValue);\n            }\n            else {\n                rulerLine\n                    .attr('y1', yScaleStart)\n                    .attr('y2', yScaleEnd)\n                    .attr('x1', sampleMatch.domainValue)\n                    .attr('x2', sampleMatch.domainValue);\n            }\n        }\n        else {\n            this.hideRuler();\n        }\n    };\n    Ruler.prototype.hideRuler = function () {\n        var svg = this.parent;\n        var ruler = DOMUtils.appendOrSelect(svg, 'g.ruler');\n        var dataPointElements = svg.selectAll('[role=graphics-symbol]');\n        dataPointElements.dispatch('mouseout');\n        this.services.events.dispatchEvent(Events.Tooltip.HIDE);\n        ruler.attr('opacity', 0);\n    };\n    /**\n     * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.\n     */\n    Ruler.prototype.addBackdropEventListeners = function () {\n        this.isEventListenerAdded = true;\n        var self = this;\n        var displayData = this.model.getDisplayData();\n        var mouseMoveCallback = function () {\n            var pos = mouse(self.parent.node());\n            self.showRuler(pos);\n        };\n        // Debounce mouseMoveCallback if there are more than 100 datapoints\n        if (displayData.length > 100) {\n            var debounceThreshold = (displayData.length % 50) * 12.5;\n            mouseMoveCallback = Tools.debounceWithD3MousePosition(function () {\n                var mousePosition = this.mousePosition;\n                self.showRuler(mousePosition);\n            }, debounceThreshold, this.parent.node());\n        }\n        this.backdrop\n            .on('mousemove mouseover', mouseMoveCallback)\n            .on('mouseout', this.hideRuler.bind(this));\n    };\n    Ruler.prototype.drawBackdrop = function () {\n        var svg = this.parent;\n        var mainXScale = this.services.cartesianScales.getMainXScale();\n        var mainYScale = this.services.cartesianScales.getMainYScale();\n        var _a = mainXScale.range(), xScaleStart = _a[0], xScaleEnd = _a[1];\n        var _b = mainYScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];\n        // Get height from the grid\n        this.backdrop = DOMUtils.appendOrSelect(svg, 'svg.chart-grid-backdrop');\n        var backdropRect = DOMUtils.appendOrSelect(this.backdrop, this.isXGridEnabled || this.isYGridEnabled\n            ? 'rect.chart-grid-backdrop.stroked'\n            : 'rect.chart-grid-backdrop');\n    };\n    return Ruler;\n}(Component));\nexport { Ruler };\n//# sourceMappingURL=../../../src/components/axes/ruler.js.map"]},"metadata":{},"sourceType":"module"}