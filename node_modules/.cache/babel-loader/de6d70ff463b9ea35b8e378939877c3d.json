{"ast":null,"code":"/**\n * Utilites to manipulate the position of elements relative to other elements\n */\nvar _a;\n\nexport var PLACEMENTS;\n\n(function (PLACEMENTS) {\n  PLACEMENTS[\"LEFT\"] = \"left\";\n  PLACEMENTS[\"RIGHT\"] = \"right\";\n  PLACEMENTS[\"TOP\"] = \"top\";\n  PLACEMENTS[\"BOTTOM\"] = \"bottom\";\n})(PLACEMENTS || (PLACEMENTS = {}));\n\nexport var defaultPositions = (_a = {}, _a[PLACEMENTS.LEFT] = function (referenceOffset, target, referenceRect) {\n  return {\n    top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n    left: Math.round(referenceOffset.left - target.offsetWidth)\n  };\n}, _a[PLACEMENTS.RIGHT] = function (referenceOffset, target, referenceRect) {\n  return {\n    top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n    left: Math.round(referenceOffset.left + referenceRect.width)\n  };\n}, _a[PLACEMENTS.TOP] = function (referenceOffset, target, referenceRect) {\n  return {\n    top: Math.round(referenceOffset.top - target.offsetHeight),\n    left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n  };\n}, _a[PLACEMENTS.BOTTOM] = function (referenceOffset, target, referenceRect) {\n  return {\n    top: Math.round(referenceOffset.top + referenceRect.height),\n    left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n  };\n}, _a);\nvar windowRef = typeof window !== \"undefined\" ? window : {\n  innerHeight: 0,\n  scrollY: 0,\n  innerWidth: 0,\n  scrollX: 0\n};\n\nvar Position =\n/** @class */\nfunction () {\n  function Position(positions) {\n    if (positions === void 0) {\n      positions = {};\n    }\n\n    this.positions = defaultPositions;\n    this.positions = Object.assign({}, defaultPositions, positions);\n  }\n\n  Position.prototype.getRelativeOffset = function (target) {\n    // start with the initial element offsets\n    var offsets = {\n      left: target.offsetLeft,\n      top: target.offsetTop\n    }; // get each static (i.e. not absolute or relative) offsetParent and sum the left/right offsets\n\n    while (target.offsetParent && getComputedStyle(target.offsetParent).position === \"static\") {\n      offsets.left += target.offsetLeft;\n      offsets.top += target.offsetTop;\n      target = target.offsetParent;\n    }\n\n    return offsets;\n  };\n\n  Position.prototype.getAbsoluteOffset = function (target) {\n    var currentNode = target;\n    var margins = {\n      top: 0,\n      left: 0\n    }; // searches for containing elements with additional margins\n\n    while (currentNode.offsetParent) {\n      var computed = getComputedStyle(currentNode.offsetParent); // find static elements with additional margins\n      // since they tend to throw off our positioning\n      // (usually this is just the body)\n\n      if (computed.position === \"static\" && computed.marginLeft && computed.marginTop) {\n        if (parseInt(computed.marginTop, 10)) {\n          margins.top += parseInt(computed.marginTop, 10);\n        }\n\n        if (parseInt(computed.marginLeft, 10)) {\n          margins.left += parseInt(computed.marginLeft, 10);\n        }\n      }\n\n      currentNode = currentNode.offsetParent;\n    }\n\n    var targetRect = target.getBoundingClientRect();\n    var relativeRect = document.body.getBoundingClientRect();\n    return {\n      top: targetRect.top - relativeRect.top + margins.top,\n      left: targetRect.left - relativeRect.left + margins.left\n    };\n  }; // finds the position relative to the `reference` element\n\n\n  Position.prototype.findRelative = function (reference, target, placement) {\n    var referenceOffset = this.getRelativeOffset(reference);\n    var referenceRect = reference.getBoundingClientRect();\n    return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n  };\n\n  Position.prototype.findAbsolute = function (reference, target, placement) {\n    var referenceOffset = this.getAbsoluteOffset(reference);\n    var referenceRect = reference.getBoundingClientRect();\n    return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n  };\n\n  Position.prototype.findPosition = function (reference, target, placement, offsetFunction) {\n    if (offsetFunction === void 0) {\n      offsetFunction = this.getAbsoluteOffset;\n    }\n\n    var referenceOffset = offsetFunction(reference);\n    var referenceRect = reference.getBoundingClientRect();\n    return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n  };\n\n  Position.prototype.findPositionAt = function (offset, target, placement) {\n    return this.calculatePosition(offset, {\n      height: 0,\n      width: 0\n    }, target, placement);\n  };\n  /**\n   * Get the dimensions of an element from an AbsolutePosition and a reference element\n   */\n\n\n  Position.prototype.getPlacementBox = function (target, position) {\n    var targetBottom = target.offsetHeight + position.top;\n    var targetRight = target.offsetWidth + position.left;\n    return {\n      top: position.top,\n      bottom: targetBottom,\n      left: position.left,\n      right: targetRight\n    };\n  };\n\n  Position.prototype.addOffset = function (position, top, left) {\n    if (top === void 0) {\n      top = 0;\n    }\n\n    if (left === void 0) {\n      left = 0;\n    }\n\n    return Object.assign({}, position, {\n      top: position.top + top,\n      left: position.left + left\n    });\n  };\n\n  Position.prototype.setElement = function (element, position) {\n    element.style.top = position.top + \"px\";\n    element.style.left = position.left + \"px\";\n  };\n\n  Position.prototype.findBestPlacement = function (reference, target, placements, containerFunction, positionFunction) {\n    var _this = this;\n\n    if (containerFunction === void 0) {\n      containerFunction = this.defaultContainerFunction;\n    }\n\n    if (positionFunction === void 0) {\n      positionFunction = this.findPosition;\n    }\n    /**\n     * map over the array of placements and weight them based on the percentage of visible area\n     * where visible area is defined as the area not obscured by the window borders\n     */\n\n\n    var weightedPlacements = placements.map(function (placement) {\n      var pos = positionFunction(reference, target, placement);\n\n      var box = _this.getPlacementBox(target, pos);\n\n      var hiddenHeight = box.bottom - containerFunction().height;\n      var hiddenWidth = box.right - containerFunction().width; // if the hiddenHeight or hiddenWidth is negative, reset to offsetHeight or offsetWidth\n\n      hiddenHeight = hiddenHeight < 0 ? target.offsetHeight : hiddenHeight;\n      hiddenWidth = hiddenWidth < 0 ? target.offsetWidth : hiddenWidth;\n      var area = target.offsetHeight * target.offsetWidth;\n      var hiddenArea = hiddenHeight * hiddenWidth;\n      var visibleArea = area - hiddenArea; // if the visibleArea is 0 set it back to area (to calculate the percentage in a useful way)\n\n      visibleArea = visibleArea === 0 ? area : visibleArea;\n      var visiblePercent = visibleArea / area;\n      return {\n        placement: placement,\n        weight: visiblePercent\n      };\n    }); // sort the placements from best to worst\n\n    weightedPlacements.sort(function (a, b) {\n      return b.weight - a.weight;\n    }); // pick the best!\n\n    return weightedPlacements[0].placement;\n  };\n\n  Position.prototype.findBestPlacementAt = function (offset, target, placements, containerFunction) {\n    var _this = this;\n\n    if (containerFunction === void 0) {\n      containerFunction = this.defaultContainerFunction;\n    }\n\n    var positionAt = function positionAt(_, target, placement) {\n      return _this.findPositionAt(offset, target, placement);\n    };\n\n    return this.findBestPlacement(null, target, placements, containerFunction, positionAt);\n  };\n\n  Position.prototype.defaultContainerFunction = function () {\n    return {\n      // we go with window here, because that's going to be the simple/common case\n      width: windowRef.innerHeight - windowRef.scrollY,\n      height: windowRef.innerWidth - windowRef.scrollX\n    };\n  };\n\n  Position.prototype.calculatePosition = function (referenceOffset, referenceRect, target, placement) {\n    if (this.positions[placement]) {\n      return this.positions[placement](referenceOffset, target, referenceRect);\n    }\n\n    console.error(\"No function found for placement, defaulting to 0,0\");\n    return {\n      left: 0,\n      top: 0\n    };\n  };\n\n  return Position;\n}();\n\nexport { Position };\nexport var position = new Position();\nexport default Position;","map":{"version":3,"sources":["/Users/zander/Documents/Development/ActionsLogging/Dashboard/node_modules/@carbon/utils-position/index.js"],"names":["_a","PLACEMENTS","defaultPositions","LEFT","referenceOffset","target","referenceRect","top","Math","round","offsetHeight","height","left","offsetWidth","RIGHT","width","TOP","BOTTOM","windowRef","window","innerHeight","scrollY","innerWidth","scrollX","Position","positions","Object","assign","prototype","getRelativeOffset","offsets","offsetLeft","offsetTop","offsetParent","getComputedStyle","position","getAbsoluteOffset","currentNode","margins","computed","marginLeft","marginTop","parseInt","targetRect","getBoundingClientRect","relativeRect","document","body","findRelative","reference","placement","calculatePosition","findAbsolute","findPosition","offsetFunction","findPositionAt","offset","getPlacementBox","targetBottom","targetRight","bottom","right","addOffset","setElement","element","style","findBestPlacement","placements","containerFunction","positionFunction","_this","defaultContainerFunction","weightedPlacements","map","pos","box","hiddenHeight","hiddenWidth","area","hiddenArea","visibleArea","visiblePercent","weight","sort","a","b","findBestPlacementAt","positionAt","_","console","error"],"mappings":"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","sourcesContent":["/**\n * Utilites to manipulate the position of elements relative to other elements\n */\nvar _a;\nexport var PLACEMENTS;\n(function (PLACEMENTS) {\n    PLACEMENTS[\"LEFT\"] = \"left\";\n    PLACEMENTS[\"RIGHT\"] = \"right\";\n    PLACEMENTS[\"TOP\"] = \"top\";\n    PLACEMENTS[\"BOTTOM\"] = \"bottom\";\n})(PLACEMENTS || (PLACEMENTS = {}));\nexport var defaultPositions = (_a = {},\n    _a[PLACEMENTS.LEFT] = function (referenceOffset, target, referenceRect) { return ({\n        top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n        left: Math.round(referenceOffset.left - target.offsetWidth)\n    }); },\n    _a[PLACEMENTS.RIGHT] = function (referenceOffset, target, referenceRect) { return ({\n        top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n        left: Math.round(referenceOffset.left + referenceRect.width)\n    }); },\n    _a[PLACEMENTS.TOP] = function (referenceOffset, target, referenceRect) { return ({\n        top: Math.round(referenceOffset.top - target.offsetHeight),\n        left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n    }); },\n    _a[PLACEMENTS.BOTTOM] = function (referenceOffset, target, referenceRect) { return ({\n        top: Math.round(referenceOffset.top + referenceRect.height),\n        left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n    }); },\n    _a);\nvar windowRef = typeof window !== \"undefined\" ? window : {\n    innerHeight: 0,\n    scrollY: 0,\n    innerWidth: 0,\n    scrollX: 0\n};\nvar Position = /** @class */ (function () {\n    function Position(positions) {\n        if (positions === void 0) { positions = {}; }\n        this.positions = defaultPositions;\n        this.positions = Object.assign({}, defaultPositions, positions);\n    }\n    Position.prototype.getRelativeOffset = function (target) {\n        // start with the initial element offsets\n        var offsets = {\n            left: target.offsetLeft,\n            top: target.offsetTop\n        };\n        // get each static (i.e. not absolute or relative) offsetParent and sum the left/right offsets\n        while (target.offsetParent && getComputedStyle(target.offsetParent).position === \"static\") {\n            offsets.left += target.offsetLeft;\n            offsets.top += target.offsetTop;\n            target = target.offsetParent;\n        }\n        return offsets;\n    };\n    Position.prototype.getAbsoluteOffset = function (target) {\n        var currentNode = target;\n        var margins = {\n            top: 0,\n            left: 0\n        };\n        // searches for containing elements with additional margins\n        while (currentNode.offsetParent) {\n            var computed = getComputedStyle(currentNode.offsetParent);\n            // find static elements with additional margins\n            // since they tend to throw off our positioning\n            // (usually this is just the body)\n            if (computed.position === \"static\" &&\n                computed.marginLeft &&\n                computed.marginTop) {\n                if (parseInt(computed.marginTop, 10)) {\n                    margins.top += parseInt(computed.marginTop, 10);\n                }\n                if (parseInt(computed.marginLeft, 10)) {\n                    margins.left += parseInt(computed.marginLeft, 10);\n                }\n            }\n            currentNode = currentNode.offsetParent;\n        }\n        var targetRect = target.getBoundingClientRect();\n        var relativeRect = document.body.getBoundingClientRect();\n        return {\n            top: targetRect.top - relativeRect.top + margins.top,\n            left: targetRect.left - relativeRect.left + margins.left\n        };\n    };\n    // finds the position relative to the `reference` element\n    Position.prototype.findRelative = function (reference, target, placement) {\n        var referenceOffset = this.getRelativeOffset(reference);\n        var referenceRect = reference.getBoundingClientRect();\n        return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n    };\n    Position.prototype.findAbsolute = function (reference, target, placement) {\n        var referenceOffset = this.getAbsoluteOffset(reference);\n        var referenceRect = reference.getBoundingClientRect();\n        return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n    };\n    Position.prototype.findPosition = function (reference, target, placement, offsetFunction) {\n        if (offsetFunction === void 0) { offsetFunction = this.getAbsoluteOffset; }\n        var referenceOffset = offsetFunction(reference);\n        var referenceRect = reference.getBoundingClientRect();\n        return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n    };\n    Position.prototype.findPositionAt = function (offset, target, placement) {\n        return this.calculatePosition(offset, { height: 0, width: 0 }, target, placement);\n    };\n    /**\n     * Get the dimensions of an element from an AbsolutePosition and a reference element\n     */\n    Position.prototype.getPlacementBox = function (target, position) {\n        var targetBottom = target.offsetHeight + position.top;\n        var targetRight = target.offsetWidth + position.left;\n        return {\n            top: position.top,\n            bottom: targetBottom,\n            left: position.left,\n            right: targetRight\n        };\n    };\n    Position.prototype.addOffset = function (position, top, left) {\n        if (top === void 0) { top = 0; }\n        if (left === void 0) { left = 0; }\n        return Object.assign({}, position, {\n            top: position.top + top,\n            left: position.left + left\n        });\n    };\n    Position.prototype.setElement = function (element, position) {\n        element.style.top = position.top + \"px\";\n        element.style.left = position.left + \"px\";\n    };\n    Position.prototype.findBestPlacement = function (reference, target, placements, containerFunction, positionFunction) {\n        var _this = this;\n        if (containerFunction === void 0) { containerFunction = this.defaultContainerFunction; }\n        if (positionFunction === void 0) { positionFunction = this.findPosition; }\n        /**\n         * map over the array of placements and weight them based on the percentage of visible area\n         * where visible area is defined as the area not obscured by the window borders\n         */\n        var weightedPlacements = placements.map(function (placement) {\n            var pos = positionFunction(reference, target, placement);\n            var box = _this.getPlacementBox(target, pos);\n            var hiddenHeight = box.bottom - containerFunction().height;\n            var hiddenWidth = box.right - containerFunction().width;\n            // if the hiddenHeight or hiddenWidth is negative, reset to offsetHeight or offsetWidth\n            hiddenHeight = hiddenHeight < 0 ? target.offsetHeight : hiddenHeight;\n            hiddenWidth = hiddenWidth < 0 ? target.offsetWidth : hiddenWidth;\n            var area = target.offsetHeight * target.offsetWidth;\n            var hiddenArea = hiddenHeight * hiddenWidth;\n            var visibleArea = area - hiddenArea;\n            // if the visibleArea is 0 set it back to area (to calculate the percentage in a useful way)\n            visibleArea = visibleArea === 0 ? area : visibleArea;\n            var visiblePercent = visibleArea / area;\n            return {\n                placement: placement,\n                weight: visiblePercent\n            };\n        });\n        // sort the placements from best to worst\n        weightedPlacements.sort(function (a, b) { return b.weight - a.weight; });\n        // pick the best!\n        return weightedPlacements[0].placement;\n    };\n    Position.prototype.findBestPlacementAt = function (offset, target, placements, containerFunction) {\n        var _this = this;\n        if (containerFunction === void 0) { containerFunction = this.defaultContainerFunction; }\n        var positionAt = function (_, target, placement) {\n            return _this.findPositionAt(offset, target, placement);\n        };\n        return this.findBestPlacement(null, target, placements, containerFunction, positionAt);\n    };\n    Position.prototype.defaultContainerFunction = function () {\n        return {\n            // we go with window here, because that's going to be the simple/common case\n            width: windowRef.innerHeight - windowRef.scrollY,\n            height: windowRef.innerWidth - windowRef.scrollX\n        };\n    };\n    Position.prototype.calculatePosition = function (referenceOffset, referenceRect, target, placement) {\n        if (this.positions[placement]) {\n            return this.positions[placement](referenceOffset, target, referenceRect);\n        }\n        console.error(\"No function found for placement, defaulting to 0,0\");\n        return { left: 0, top: 0 };\n    };\n    return Position;\n}());\nexport { Position };\nexport var position = new Position();\nexport default Position;\n//# sourceMappingURL=../src/index.js.map"]},"metadata":{},"sourceType":"module"}