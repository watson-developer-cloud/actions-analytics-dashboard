{"ast":null,"code":"import { TextAnchor, DominantBaseline } from '../interfaces/enums';\nexport function radialLabelPlacement(angleRadians) {\n  var angle = mod(radToDeg(angleRadians), 360);\n\n  if (isInRange(angle, [0, 10]) || isInRange(angle, [350, 0])) {\n    return {\n      textAnchor: TextAnchor.START,\n      dominantBaseline: DominantBaseline.MIDDLE\n    };\n  } else if (isInRange(angle, [10, 80])) {\n    return {\n      textAnchor: TextAnchor.START,\n      dominantBaseline: DominantBaseline.HANGING\n    };\n  } else if (isInRange(angle, [80, 100])) {\n    return {\n      textAnchor: TextAnchor.MIDDLE,\n      dominantBaseline: DominantBaseline.HANGING\n    };\n  } else if (isInRange(angle, [100, 170])) {\n    return {\n      textAnchor: TextAnchor.END,\n      dominantBaseline: DominantBaseline.HANGING\n    };\n  } else if (isInRange(angle, [170, 190])) {\n    return {\n      textAnchor: TextAnchor.END,\n      dominantBaseline: DominantBaseline.MIDDLE\n    };\n  } else if (isInRange(angle, [190, 260])) {\n    return {\n      textAnchor: TextAnchor.END,\n      dominantBaseline: DominantBaseline.BASELINE\n    };\n  } else if (isInRange(angle, [260, 280])) {\n    return {\n      textAnchor: TextAnchor.MIDDLE,\n      dominantBaseline: DominantBaseline.BASELINE\n    };\n  } else {\n    // 280 - 350\n    return {\n      textAnchor: TextAnchor.START,\n      dominantBaseline: DominantBaseline.BASELINE\n    };\n  }\n}\n\nfunction mod(n, m) {\n  return (n % m + m) % m;\n}\n\nfunction isInRange(x, _a) {\n  var min = _a[0],\n      max = _a[1];\n  return x >= min && x <= max;\n}\n\nexport function radToDeg(rad) {\n  return rad * (180 / Math.PI);\n}\nexport function degToRad(deg) {\n  return deg * (Math.PI / 180);\n}\nexport function polarToCartesianCoords(a, r, t) {\n  if (t === void 0) {\n    t = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var x = r * Math.cos(a) + t.x;\n  var y = r * Math.sin(a) + t.y;\n  return {\n    x: x,\n    y: y\n  };\n} // Return the distance between a point (described with polar coordinates)\n// on a circumference and the vertical diameter.\n// If the point is on the left if the diameter, its distance is positive,\n// if it is on the right of the diameter, its distance is negative.\n\nexport function distanceBetweenPointOnCircAndVerticalDiameter(a, r) {\n  return r * Math.sin(a - Math.PI / 2);\n}","map":{"version":3,"sources":["/Users/zander/Documents/Development/ActionsLogging/Dashboard/node_modules/@carbon/charts/services/angle-utils.js"],"names":["TextAnchor","DominantBaseline","radialLabelPlacement","angleRadians","angle","mod","radToDeg","isInRange","textAnchor","START","dominantBaseline","MIDDLE","HANGING","END","BASELINE","n","m","x","_a","min","max","rad","Math","PI","degToRad","deg","polarToCartesianCoords","a","r","t","y","cos","sin","distanceBetweenPointOnCircAndVerticalDiameter"],"mappings":"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","sourcesContent":["import { TextAnchor, DominantBaseline } from '../interfaces/enums';\nexport function radialLabelPlacement(angleRadians) {\n    var angle = mod(radToDeg(angleRadians), 360);\n    if (isInRange(angle, [0, 10]) || isInRange(angle, [350, 0])) {\n        return {\n            textAnchor: TextAnchor.START,\n            dominantBaseline: DominantBaseline.MIDDLE,\n        };\n    }\n    else if (isInRange(angle, [10, 80])) {\n        return {\n            textAnchor: TextAnchor.START,\n            dominantBaseline: DominantBaseline.HANGING,\n        };\n    }\n    else if (isInRange(angle, [80, 100])) {\n        return {\n            textAnchor: TextAnchor.MIDDLE,\n            dominantBaseline: DominantBaseline.HANGING,\n        };\n    }\n    else if (isInRange(angle, [100, 170])) {\n        return {\n            textAnchor: TextAnchor.END,\n            dominantBaseline: DominantBaseline.HANGING,\n        };\n    }\n    else if (isInRange(angle, [170, 190])) {\n        return {\n            textAnchor: TextAnchor.END,\n            dominantBaseline: DominantBaseline.MIDDLE,\n        };\n    }\n    else if (isInRange(angle, [190, 260])) {\n        return {\n            textAnchor: TextAnchor.END,\n            dominantBaseline: DominantBaseline.BASELINE,\n        };\n    }\n    else if (isInRange(angle, [260, 280])) {\n        return {\n            textAnchor: TextAnchor.MIDDLE,\n            dominantBaseline: DominantBaseline.BASELINE,\n        };\n    }\n    else {\n        // 280 - 350\n        return {\n            textAnchor: TextAnchor.START,\n            dominantBaseline: DominantBaseline.BASELINE,\n        };\n    }\n}\nfunction mod(n, m) {\n    return ((n % m) + m) % m;\n}\nfunction isInRange(x, _a) {\n    var min = _a[0], max = _a[1];\n    return x >= min && x <= max;\n}\nexport function radToDeg(rad) {\n    return rad * (180 / Math.PI);\n}\nexport function degToRad(deg) {\n    return deg * (Math.PI / 180);\n}\nexport function polarToCartesianCoords(a, r, t) {\n    if (t === void 0) { t = { x: 0, y: 0 }; }\n    var x = r * Math.cos(a) + t.x;\n    var y = r * Math.sin(a) + t.y;\n    return { x: x, y: y };\n}\n// Return the distance between a point (described with polar coordinates)\n// on a circumference and the vertical diameter.\n// If the point is on the left if the diameter, its distance is positive,\n// if it is on the right of the diameter, its distance is negative.\nexport function distanceBetweenPointOnCircAndVerticalDiameter(a, r) {\n    return r * Math.sin(a - Math.PI / 2);\n}\n//# sourceMappingURL=../../src/services/angle-utils.js.map"]},"metadata":{},"sourceType":"module"}